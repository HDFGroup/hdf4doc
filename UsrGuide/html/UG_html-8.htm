<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 11.0/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="UG_html.css" CHARSET="UTF-8" TYPE="text/css">
<table id="Topofpage" border="0" width="850" cellspacing="0" cellpadding="0"><tr><td align="left"><a href="http://www.hdfgroup.org"><img id="THG_logo" border="0" src="images/hdf_logo.jpg" width="90" height="70" alt="The HDF Group" valign="top" /></a></td><td valign="middle" align="center"><H1>HDF User’s Guide</H1><span style="font-size: 14px; font-weight: bold"><b>4.2.10</b></td><td valign="middle" align="center"><a HREF=UG_html.htm> [Top]</a> <a HREF=UG_html-7.htm> [Prev]</a><a HREF=UG_html-9.htm> [Next]</a></td></tr></table><HR></HEAD>
<BODY>
<DIV>
<span style="font-size: 14px; font-weight: bold"><a href="UG_html-17.htm">Index</a>] [<a href="UG_html-20.htm">List of Examples</a>] [<a href="UG_html-19.htm">List of Tables</a>] [<a href="UG_html-18.htm">List of Figures</a>]</DIV>
<H1 CLASS="ChapterTitle">
<A NAME="50593878_pgfId-126681"></A>Chapter 8 --	<A NAME="50593878_29022"></A>G<A NAME="50593878_marker-44613"></A>eneral Raster Images (GR API)</H1>
<DIV>
<H4 CLASS="Heading1">
<A NAME="50593878_pgfId-1583"></A>	8.1	Chapter Overview<DIV>
<IMG SRC="UG_html-50.gif" ALT="">
</DIV>
</H4>
<P CLASS="Body">
<A NAME="50593878_pgfId-124956"></A>This chapter describes the general raster (GR) data model, the GR interface (also called the GR API), and the interface routines used to manipulate GR data objects. The GR data model is designed to provide a flexible means of manipulating raster images. There were two other interfaces that worked with raster images, the DFR8 interface (<A HREF="UG_html-6.htm#50593876_20224" CLASS="XRef">8-Bit Raster Images (DFR8 API)</A>) and the DF24 interface (<A HREF="UG_html-7.htm#50593877_18201" CLASS="XRef">24-bit is it Raster Images (DF24 API)</A>) but the GR interface supersedes them.</P>
<DIV>
<H5 CLASS="Heading2">
<A NAME="50593878_pgfId-124964"></A>	8.2	The <A NAME="50593878_marker-124963"></A>GR Data Model<DIV>
<IMG SRC="UG_html-50.gif" ALT="">
</DIV>
</H5>
<P CLASS="Body">
<A NAME="50593878_pgfId-36924"></A>HDF users familiar with the SD interface will find certain aspects of the GR data model similar to the SD data model. The interfaces are similar in that both interfaces support data storage in multiple files, attributes, compression, and chunking. They are dissimilar in that palettes can be created and attached to an image through GR interface routines, customized dimension information is not supported in the GR interface, and GR dataset chunking is constrained to two dimensions. </P>
<DIV>
<H6 CLASS="Figure">
<A NAME="50593878_pgfId-55575"></A><DIV>
<IMG SRC="UG_html-51.gif" ALT="">
</DIV>
FIGURE 8a	<A NAME="50593878_36422"></A>GR Data Set Contents</H6>
<DIV>
<IMG SRC="UG_html-52.gif" ALT="">
</DIV>
<P CLASS="Body">
<A NAME="50593878_pgfId-55597"></A>The terms <EM CLASS="Definition">
GR data set</EM>
, <EM CLASS="Definition">
raster image</EM>
, and <EM CLASS="Definition">
image </EM>
are used interchangeably in this chapter.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-55587"></A>Refer to <A HREF="UG_html-8.htm#50593878_36422" CLASS="XRef">GR Data Set Contents</A> for a graphical overview of the raster image, or GR data set, structure. Note that GR data sets consist of required and optional components.</P>
</DIV>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-55578"></A>	8.2.1	<A NAME="50593878_36435"></A>Re<A NAME="50593878_marker-55577"></A>quired GR Data Set Components</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-6299"></A>Every GR data set must contain the following components: <EM CLASS="Definition">
image array</EM>
, <EM CLASS="Definition">
name</EM>
, <EM CLASS="Definition">
pixel type</EM>
, and <EM CLASS="Definition">
dimensions</EM>
. The name, dimensions, and pixel type must be supplied by the user at the time the GR data set is defined.</P>
<DIV>
<H6 CLASS="BodyBold">
<A NAME="50593878_pgfId-6300"></A>Ima<A NAME="50593878_marker-22458"></A>ge Array</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-44273"></A>An <EM CLASS="Definition">
image array</EM>
 is a two-dimensional array of pixels. This is the primary data component of the GR model and will be discussed later in this section; it can be compressed, chunked, and/or stored in external files. Refer to <A HREF="UG_html-8.htm#50593878_19774" CLASS="XRef">Compressing Raster Images: GRsetcompress</A> for a description of raster image compression and <A HREF="UG_html-8.htm#50593878_13823" CLASS="XRef">External File Operations Using the GR Interface</A> for a description of external image storage.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-44334"></A>A raster image has an index and a reference number associated with it. The <EM CLASS="Definition">
index</EM>
<A NAME="50593878_marker-44409"></A> is a non-negative integer that describes the relative position of the raster image in the file. A valid index ranges from 0 to the total number of images in the file minus 1. The <EM CLASS="Definition">
reference number</EM>
<A NAME="50593878_marker-44410"></A> is a unique positive integer assigned to the raster image by the GR interface when the image is created. Various GR interface routines can be used to obtain an image index or reference number depending on the available information about the raster image. The index can also be determined if the sequence in which the images are created in the file is known.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-44336"></A>In the GR interface, a <EM CLASS="Definition">
raster image identifier</EM>
<A NAME="50593878_marker-44344"></A> uniquely identifies a raster image within the file. The identifier is generated by the GR interface access routines when a new GR data set is created or an existing one is selected. The identifier is then used by other GR interface routines to access the raster image until the access to this image is terminated. For an existing raster image, the index of the image can be used to obtain the identifier.</P>
</DIV>
<DIV>
<H6 CLASS="BodyBold">
<A NAME="50593878_pgfId-6302"></A>Image<A NAME="50593878_marker-22459"></A> Array Name</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-6303"></A>Each image array has a <EM CLASS="Definition">
name</EM>
 consisting of a string of case-sensitive alphanumeric characters. The name must be provided by the calling program at the time the image is created, and cannot be changed afterward. Image array names do not have to be unique within a file, but if they are not it can be difficult to distinguish among the raster images in the file.</P>
</DIV>
<DIV>
<H6 CLASS="BodyBold">
<A NAME="50593878_pgfId-6304"></A><A NAME="50593878_15606"></A>Pi<A NAME="50593878_marker-22460"></A>xels and Pixel Type</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-31406"></A>Each element in an image array corresponds to one <EM CLASS="Definition">
pixel</EM>
 and each pixel can consist of a number of color component values or <EM CLASS="Definition">
pixel components</EM>
, e.g., Red-Green-Blue or RGB, Cyan-Magenta-Yellow-Black or CMYK, etc. Pixel components can be represented by different methods (8-bit lookup table or 24-bit direct representation, graphically depicted by <A HREF="UG_html-6.htm#50593876_89021" CLASS="XRef">8-Bit Raster Image Set Contents</A> and <A HREF="UG_html-7.htm#50593877_36368" CLASS="XRef">The Numerical Representation of a 24-Bit Raster Image</A>, respectively) and may have different data types. </P>
<P CLASS="Body">
<A NAME="50593878_pgfId-36821"></A>The data type of pixel components and the number of components in each pixel are collectively known as the <EM CLASS="Definition">
pixel type</EM>
<A NAME="50593878_marker-36822"></A>. The GR data model supports all of the HDF-supported data types. A list of these data types appears provided in <A HREF="UG_html-2.htm#50593872_13047" CLASS="XRef">Standard HDF Data Types and Flags</A>.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-36832"></A>Pixels can be composed of any number of components.</P>
</DIV>
<DIV>
<H6 CLASS="BodyBold">
<A NAME="50593878_pgfId-44371"></A>Dimensions</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-44288"></A>Image array <EM CLASS="Definition">
dimensions</EM>
 specify the shape of the image array. A raster image array has two limited dimensions. The size of each dimension must be specified at the creation of the image and must be greater than 0.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-56916"></A>The GR library does not allow the HDF user to add attributes to a dimension or to set dimension scale.<A NAME="50593878_marker-56917"></A></P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-56919"></A>	8.2.2	Opt<A NAME="50593878_marker-56918"></A>ional GR Data Set Components</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-56920"></A>There are two types of optional components available for inclusion in a GR data set: palettes and attributes. These components are only created when specifically requested by the calling program; the GR interface does not provide predefined palettes or attributes.</P>
<DIV>
<H6 CLASS="BodyBold">
<A NAME="50593878_pgfId-18567"></A>Pale<A NAME="50593878_marker-22466"></A>ttes</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-18568"></A><EM CLASS="Definition">
Palettes</EM>
 are lookup tables attached to images and define a set of color values for each pixel value in the image array. The GR interface provides similar capabilities for storing and manipulating palettes as the DFP interface described in <A HREF="UG_html-9.htm#50593879_27404" CLASS="XRef">Palettes (DFP API)</A>. However, the DFP interface is restricted to single-file operations while the GR interface allows multifile palette operations.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-36967"></A>Eventually, all palette manipulation functionality will reside only within the GR interface. In the meantime, the single-file DFP routines are fully compatible with palettes created with the GR palette routines. The GR palette routines are described in <A HREF="UG_html-8.htm#50593878_31041" CLASS="XRef">Reading and Writing Palette Data Using the GR Interface</A>.</P>
</DIV>
<DIV>
<H6 CLASS="BodyBold">
<A NAME="50593878_pgfId-6315"></A>Attri<A NAME="50593878_marker-22467"></A>butes</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-18559"></A><EM CLASS="Definition">
Attributes</EM>
 contain auxiliary information about a file, a raster image, or both. The concept of attributes is described in <A HREF="UG_html-3.htm#50593873_13938" CLASS="XRef">Scientific Data Sets (SD API)</A>.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-30340"></A>The GR interface does not support dimension <A NAME="50593878_marker-56924"></A>attributes.<A NAME="50593878_marker-22455"></A></P>
</DIV>
</DIV>
</DIV>
<DIV>
<H5 CLASS="Heading2">
<A NAME="50593878_pgfId-18560"></A>	8.3	Th<A NAME="50593878_marker-22468"></A>e GR Interface<DIV>
<IMG SRC="UG_html-50.gif" ALT="">
</DIV>
</H5>
<P CLASS="Body">
<A NAME="50593878_pgfId-7386"></A>The GR consists of routines for storing, retrieving, and manipulating the data in GR data sets. </P>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-7387"></A>	8.3.1	GR <A NAME="50593878_marker-22469"></A>Interface Routines</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-31929"></A>All C routine names in the GR interface have the prefix <EM CLASS="FunctionName">
GR</EM>
 and the equivalent FORTRAN-77 routine names are prefaced by <EM CLASS="FunctionName">
mg</EM>
. All GR routines are classifiable within one of the following categories:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="50593878_pgfId-31930"></A><EM CLASS="Definition">
Access routines</EM>
 initialize and terminate access to the GR interface and raster images.</LI>
<LI CLASS="Bullet">
<A NAME="50593878_pgfId-7391"></A><EM CLASS="Definition">
Raster image manipulation routines</EM>
 modify the data and metadata contained in a GR data set.</LI>
<LI CLASS="Bullet">
<A NAME="50593878_pgfId-51497"></A><EM CLASS="Definition">
LUT manipulation routines</EM>
 modify the palettes, also called color lookup tables or LUTs, contained in a GR data set.</LI>
<LI CLASS="Bullet">
<A NAME="50593878_pgfId-7986"></A><EM CLASS="Definition">
Maintenance routines</EM>
 create the data and metadata contained in a GR data set and modify global settings governing the format of the stored data.</LI>
<LI CLASS="Bullet">
<A NAME="50593878_pgfId-7392"></A><EM CLASS="Definition">
Inquiry routines</EM>
 return information about data contained in a GR data set.</LI>
<LI CLASS="Bullet">
<A NAME="50593878_pgfId-63230"></A><EM CLASS="Definition">
Chunking routines</EM>
 are used to define data chunking parameters, to retrieve chunking information, and to write and read chunked GR data sets.</LI>
</UL>
<P CLASS="Body">
<A NAME="50593878_pgfId-7396"></A>The GR routines are listed in the following table and described further in subsequent sections of this chapter.</P>
<DIV>
<H6 CLASS="Table">
<A NAME="50593878_pgfId-7681"></A><DIV>
<IMG SRC="UG_html-51.gif" ALT="">
</DIV>
GR Libr<A NAME="50593878_marker-22470"></A>ary Routines</H6>
<TABLE>
<TR>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-55970"></A>Purpose</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-55972"></A>Routine Name7</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-55976"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-55980"></A>C</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-55982"></A>FORTRAN-77</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="5" COLSPAN="1">
<P CLASS="TableCategory">
<A NAME="50593878_pgfId-56299"></A> Access</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56307"></A>GRstart</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56309"></A>mgstart</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-56314"></A>Initializes the GR interface (<A HREF="UG_html-8.htm#50593878_19873" CLASS="XRef">Accessing Images and Files: GRstart, GRselect, and GRcreate</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-55988"></A>GRcreate</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-55990"></A>mgcreat</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-55995"></A>Creates a new raster image (<A HREF="UG_html-8.htm#50593878_19873" CLASS="XRef">Accessing Images and Files: GRstart, GRselect, and GRcreate</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56325"></A>GRselect</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56327"></A>mgselct</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-56332"></A>Selects the raster image (<A HREF="UG_html-8.htm#50593878_19873" CLASS="XRef">Accessing Images and Files: GRstart, GRselect, and GRcreate</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56010"></A>GRendaccess</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56012"></A>mgendac</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-56017"></A>Terminates access to the raster image (<A HREF="UG_html-8.htm#50593878_27202" CLASS="XRef">Terminating Access to Images and Files: GRendaccess and GRend</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56316"></A>GRend</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56318"></A>mgend</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-56323"></A>Terminates access to the GR interface (<A HREF="UG_html-8.htm#50593878_27202" CLASS="XRef">Terminating Access to Images and Files: GRendaccess and GRend</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="8" COLSPAN="1">
<P CLASS="TableCategory">
<A NAME="50593878_pgfId-56041"></A>Raster Image Manipulation</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56043"></A>GRgetattr</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56045"></A>mggnatt/</P>
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56046"></A>mggcatt</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-56050"></A>Reads an attribute of a raster image or a file (<A HREF="UG_html-8.htm#50593878_17499" CLASS="XRef">Reading User-defined Attributes: GRgetattr</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56055"></A>GRidtoref</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56057"></A>mgid2rf</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-56061"></A>Maps a raster image identifier to a reference number (<A HREF="UG_html-8.htm#50593878_10010" CLASS="XRef">Obtaining the Reference Number of a Raster Image from Its Identifier: GRidtoref</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56066"></A>GRnametoindex</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56068"></A>mgn2ndx</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-56072"></A>Maps the name of a raster image name to an index (<A HREF="UG_html-8.htm#50593878_17067" CLASS="XRef">Obtaining the Index of a Raster Image from Its Name: GRnametoindex</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56077"></A>GRreadimage</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56079"></A>mgrdimg/</P>
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56080"></A>mgrcimg</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-56085"></A>Reads raster image data (<A HREF="UG_html-8.htm#50593878_24692" CLASS="XRef">Reading Data from an Image: GRreadimage</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56089"></A>GRreftoindex</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56091"></A>mgr2idx</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-56093"></A>Maps the reference number of a raster image to its index (<A HREF="UG_html-8.htm#50593878_28236" CLASS="XRef">Obtaining the Index of a Raster Image from Its Reference Number: GRreftoindex</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56100"></A>GRsetattr</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56102"></A>mgsnatt/</P>
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56103"></A>mgscatt</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-56107"></A>Assigns an attribute to a raster image or a file (<A HREF="UG_html-8.htm#50593878_33193" CLASS="XRef">Setting User-defined Attributes: GRsetattr</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56112"></A>GRwriteimage</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56114"></A>mgwrimg/mgwcimg</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-56119"></A>Writes raster image data (<A HREF="UG_html-8.htm#50593878_11596" CLASS="XRef">Writing Raster Images: GRwriteimage</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56123"></A>GRreqimageil</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56125"></A>mgrimil</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-56127"></A>Sets the interlace mode of the image read for subsequent read operations (<A HREF="UG_html-8.htm#50593878_26886" CLASS="XRef">Setting the Interlace Mode for an Image Read: GRreqimageil</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="6" COLSPAN="1">
<P CLASS="TableCategory">
<A NAME="50593878_pgfId-56132"></A>LUT             Manipulation</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56134"></A>GRgetlutid</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56136"></A>mggltid</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-56140"></A>Gets a palette identifier given the palette’s index (<A HREF="UG_html-8.htm#50593878_13955" CLASS="XRef">Obtaining a Palette Identifier: GRgetlutid</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56145"></A>GRluttoref</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56147"></A>mglt2rf</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-56151"></A>Maps a palette identifier to a reference number (<A HREF="UG_html-8.htm#50593878_22530" CLASS="XRef">Obtaining the Reference Number of a Specified Palette: GRluttoref</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56156"></A>GRreadlut</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56158"></A>mgrdlut/</P>
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56159"></A>mgrclut</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-56164"></A>Reads palette data from a raster image (<A HREF="UG_html-8.htm#50593878_24546" CLASS="XRef">Reading Palette Data: GRreadlut</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56168"></A>GRwritelut</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56170"></A>mgwrlut/</P>
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56171"></A>mgwclut</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-56176"></A>Writes palette data to a raster image (<A HREF="UG_html-8.htm#50593878_37998" CLASS="XRef">Writing Palette Data: GRwritelut</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-66162"></A>GRreqlutil</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-66164"></A>mgrltil</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-66166"></A>Sets the interlace mode of the next palette for subsequent read operations (<A HREF="UG_html-8.htm#50593878_26886" CLASS="XRef">Setting the Interlace Mode for an Image Read: GRreqimageil</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-66171"></A>GRgetnluts</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-66173"></A>mggnluts</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-66175"></A>Retrieves the number of palettes associated with an image  (See the HDF Reference Manual)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="4" COLSPAN="1">
<P CLASS="TableCategory">
<A NAME="50593878_pgfId-56189"></A>Miscenlaneous</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-77122"></A>GRsetcompress</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56193"></A>mgscomp</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-56195"></A>Specifies whether the raster image will be stored in a file as a compressed raster image (<A HREF="UG_html-8.htm#50593878_19774" CLASS="XRef">Compressing Raster Images: GRsetcompress</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-66135"></A>GRgetcompinfo</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-66137"></A>mggcompress</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-66139"></A>Retrieves image compression type and compression information  (<A HREF="UG_html-8.htm#50593878_54086" CLASS="XRef">Obtaining Compression Information for a Raster Image: GRgetcompinfo</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56202"></A>GRsetexternalfile</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56204"></A>mgsxfil</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-56206"></A>Specifies that the raster image will be written to an external file (<A HREF="UG_html-8.htm#50593878_10019" CLASS="XRef">Creating a Raster Image in an External File: GRsetexternalfile</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-124994"></A>GRsetaccesstype</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-124996"></A>nmgsactp</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-124998"></A>Sets the access for an RI to be either serial or parallel I/O ()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="5" COLSPAN="1">
<P CLASS="TableCategory">
<A NAME="50593878_pgfId-56211"></A>Inquiry</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56213"></A>GRattrinfo</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56215"></A>mgatinf</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-56220"></A>Retrieves information about an attribute (<A HREF="UG_html-8.htm#50593878_11523" CLASS="XRef">Querying User-Defined Attributes: GRfindattr and GRattrinfo</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56224"></A>GRfindattr</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56226"></A>mgfndat</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-56228"></A>Finds the index of a data object's attribute given an attribute name (<A HREF="UG_html-8.htm#50593878_11523" CLASS="XRef">Querying User-Defined Attributes: GRfindattr and GRattrinfo</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56235"></A>GRfileinfo</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56237"></A>mgfinfo</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-56239"></A>Retrieves the number of raster images and the number of global attributes in the file (<A HREF="UG_html-8.htm#50593878_18290" CLASS="XRef">Obtaining Information about the Contents of a File: GRfileinfo</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56246"></A>GRgetiminfo</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56248"></A>mggiinf</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-56252"></A>Retrieves general information about a raster image (<A HREF="UG_html-8.htm#50593878_21293" CLASS="XRef">Obtaining Information about an Image: GRgetiminfo</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56257"></A>GRgetlutinfo</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56259"></A>mgglinf</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-56264"></A>Retrieves information about a palette (<A HREF="UG_html-8.htm#50593878_15860" CLASS="XRef">Obtaining Palette Information: GRgetlutinfo</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="5" COLSPAN="1">
<P CLASS="TableCategory">
<A NAME="50593878_pgfId-56266"></A>Chunking</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56268"></A>GRsetchunk</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56270"></A>mgschnk</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-56275"></A>Creates chunked raster image (<A HREF="UG_html-8.htm#50593878_24765" CLASS="XRef">Making a Raster Image a Chunked Raster Image: GRsetchunk</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56279"></A>GRgetchunkinfo</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56281"></A>mggichnk</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-56285"></A>Retrieves information about a chunked raster image (<A HREF="UG_html-8.htm#50593878_33313" CLASS="XRef">Obtaining Information about a Chunked Raster Image: GRgetchunkinfo</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56290"></A>GRsetchunkcache</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-56292"></A>mgscchnk</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-56296"></A>Sets maximum number of chunks to be cached (<A HREF="UG_html-8.htm#50593878_36329" CLASS="XRef">Setting the Maximum Number of Chunks in the Cache: GRsetchunkcache</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-61748"></A>GRreadchunk</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-61750"></A>mgrchnk/</P>
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-63251"></A>mgrcchnk</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-61752"></A>Reads a data chunk from a chunked raster image (pixel-interlace only) (<A HREF="UG_html-8.htm#50593878_48842" CLASS="XRef">Reading a Chunked Raster Image: GRreadchunk</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-61734"></A>GRwritechunk</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-61736"></A>mgwchnk/</P>
<P CLASS="CellFunction">
<A NAME="50593878_pgfId-63252"></A>mgwcchnk</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-61738"></A>Writes a data chunk to a chunked raster image (pixel-interlace only) (<A HREF="UG_html-8.htm#50593878_68057" CLASS="XRef">Writing a Chunked Raster Image: GRwritechunk</A>)</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
</DIV>
<DIV>
<H5 CLASS="Heading2">
<A NAME="50593878_pgfId-22475"></A>	8.4	Header Files Required by the GR Interface<DIV>
<IMG SRC="UG_html-50.gif" ALT="">
</DIV>
</H5>
<DIV>
<H6 CLASS="Body1">
<A NAME="50593878_pgfId-27136"></A><A NAME="50593878_marker-27135"></A>The header file &quot;hdf.h&quot; must be included in any program that utilizes GR interface routines.</H6>
</DIV>
</DIV>
<DIV>
<H5 CLASS="Heading2">
<A NAME="50593878_pgfId-27125"></A>	8.5	Prog<A NAME="50593878_marker-27124"></A>ramming Model for the GR Interface<DIV>
<IMG SRC="UG_html-50.gif" ALT="">
</DIV>
</H5>
<P CLASS="Body">
<A NAME="50593878_pgfId-7690"></A>As with the SD interface, the GR interface relies on the calling program to initiate and terminate access to files and data sets to support multifile access. The GR programming model for accessing a raster image is as follows:</P>
<DIV>
<H6 CLASS="FM1Step">
<A NAME="50593878_pgfId-7691"></A>Open an HDF file.</H6>
<OL>
<LI CLASS="Step">
<A NAME="50593878_pgfId-8464"></A>2.	Initialize the GR interface.</LI>
<LI CLASS="Step">
<A NAME="50593878_pgfId-7692"></A>3.	Open an existing raster image or create a new raster image.</LI>
<LI CLASS="Step">
<A NAME="50593878_pgfId-7693"></A>4.	Perform desired operations on the raster image.</LI>
<LI CLASS="Step">
<A NAME="50593878_pgfId-7694"></A>5.	Terminate access to the raster image.</LI>
<LI CLASS="Step">
<A NAME="50593878_pgfId-7695"></A>6.	Terminate access to the GR interface by disposing of the interface identifier.</LI>
<LI CLASS="Step">
<A NAME="50593878_pgfId-8503"></A>7.	Close the HDF file.</LI>
</OL>
<P CLASS="Body">
<A NAME="50593878_pgfId-57066"></A>To access a single raster image data set in an HDF file, the calling program must contain the following calls:</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-57067"></A><EM CLASS="syntaxLang">
C:</EM>
		file_id = Hopen(filename, access_mode, n_dds_block);</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-57068"></A>		gr_id = GRstart(file_id);</P>
<P CLASS="syntax-or-top">
<A NAME="50593878_pgfId-57041"></A>		ri_id = GRselect(gr_id, ri_index);</P>
<P CLASS="syntax-or-bot">
<A NAME="50593878_pgfId-57042"></A>	<EM CLASS="syntaxLang">
OR</EM>
	ri_id = GRcreate(gr_id, name, n_comps, data_type, interlace_mode, dim_sizes);</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-7699"></A>		&lt;Optional operations&gt;</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-7700"></A>		status = GRendaccess(ri_id);</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-7701"></A>		status = GRend(gr_id);</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-57083"></A>		status = Hclose(file_id);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-57084"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	file_id = hopen(filename, access_mode, n_dds_block)</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-57085"></A>		gr_id = mgstart(file_id)</P>
<P CLASS="syntax-or-top">
<A NAME="50593878_pgfId-7704"></A>		ri_id = mgselct(gr_id, ri_index)</P>
<P CLASS="syntax-or-bot">
<A NAME="50593878_pgfId-31385"></A><EM CLASS="syntaxLang">
	OR</EM>
	ri_id = mgcreat(gr_id, name, n_comps, data_type, interlace_mode, dim_sizes)</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-7705"></A>		&lt;Optional operations&gt;</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-7706"></A>		status = mgendac(ri_id)</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-8542"></A>		status = mgend(gr_id)</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-8543"></A>		status = hclose(file_id)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-30885"></A>To access several files at the same time, a calling program must obtain a separate interface identifier for each file to be opened. Similarly, to access more than one raster image, a calling program must obtain a separate data set identifier for each data set. </P>
<P CLASS="Body">
<A NAME="50593878_pgfId-7728"></A>Because every file and raster image is assigned its own identifier, the order in which files and data sets are accessed is very flexible as long as all file and raster image identifiers are individually discarded before the end of the calling program.</P>
</DIV>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-7730"></A>	8.5.1	<A NAME="50593878_19873"></A>Access<A NAME="50593878_marker-22479"></A>ing Images and Files: GRstart, GRselect, and GRcreate</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-7731"></A>In the GR interface, <EM CLASS="FunctionName">
Hopen</EM>
 opens the files and <EM CLASS="FunctionName">
GRstart</EM>
 initiates the GR interface. Note the contrast to the SD interface, where <EM CLASS="FunctionName">
SDstart</EM>
 performs both tasks. For information on the use of <EM CLASS="FunctionName">
Hopen</EM>
, refer to <A HREF="UG_html-2.htm#50593872_13138" CLASS="XRef">HDF Fundamentals</A>. For information on <EM CLASS="FunctionName">
SDstart</EM>
, refer to <A HREF="UG_html-3.htm#50593873_13938" CLASS="XRef">Scientific Data Sets (SD API)</A>.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-8720"></A><EM CLASS="FunctionName">
GRstart</EM>
<A NAME="50593878_marker-22480"></A> initializes the GR interface and must be called once after <EM CLASS="FunctionName">
Hopen</EM>
 and before any other GR routines are called. It takes one argument, <EM CLASS="VarName">
file_id</EM>
, the file identifier returned by <EM CLASS="FunctionName">
Hopen</EM>
, and returns the interface identifier <EM CLASS="VarName">
gr_id</EM>
 or <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
) upon unsuccessful completion. <EM CLASS="FunctionName">
Hopen</EM>
 and <EM CLASS="FunctionName">
GRstart</EM>
 can be called several times to access more than one file.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-19914"></A><EM CLASS="FunctionName">
GRselect</EM>
<A NAME="50593878_marker-22481"></A> specifies the given image as the current image to be accessed. It takes two arguments, the GR interface identifier <EM CLASS="VarName">
gr_id</EM>
 and the raster image index <EM CLASS="VarName">
ri_index</EM>
, and returns the raster image identifier <EM CLASS="VarName">
ri_id</EM>
 or <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
) upon unsuccessful completion. The GR interface identifier is returned by <EM CLASS="FunctionName">
GRstart</EM>
. The raster image index specifies the position of the image relative to the beginning of the file; it is zero-based, meaning that the index of the first image in the file is <EM CLASS="Superscript">
0</EM>
. The index of a raster image can be obtained from the image’s name using the routine <EM CLASS="FunctionName">
GRnametoindex</EM>
 or from the image’s reference number using <EM CLASS="FunctionName">
GRreftoindex</EM>
. These routines are discussed in <EM CLASS="Body">
<A HREF="UG_html-8.htm#50593878_28236" CLASS="XRef">Obtaining the Index of a Raster Image from Its Reference Number: GRreftoindex</A></EM>
 and <A HREF="UG_html-8.htm#50593878_17067" CLASS="XRef">Obtaining the Index of a Raster Image from Its Name: GRnametoindex</A>. The index value must be less than the total number of raster images in the file; that number can be obtained using <EM CLASS="FunctionName">
GRfileinfo</EM>
, described in <EM CLASS="Body">
<A HREF="UG_html-8.htm#50593878_18290" CLASS="XRef">Obtaining Information about the Contents of a File: GRfileinfo</A></EM>
.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-31076"></A>The parameters for <EM CLASS="FunctionName">
GRstart</EM>
 and <EM CLASS="FunctionName">
GRselect</EM>
 are further defined in <A HREF="UG_html-8.htm#50593878_12133" CLASS="XRef">GRstart, GRselect, GRcreate, GRendaccess, and GRend, Parameter Lists</A>.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-43731"></A><EM CLASS="FunctionName">
GRcreate</EM>
<A NAME="50593878_marker-43730"></A> defines a new raster image using the arguments <EM CLASS="VarName">
gr_id</EM>
, <EM CLASS="VarName">
name</EM>
, <EM CLASS="VarName">
n_comps</EM>
, <EM CLASS="VarName">
data_type</EM>
, <EM CLASS="VarName">
interlace_mode</EM>
, and <EM CLASS="VarName">
dim_sizes</EM>
. Once a data set is created, you cannot change its name, data type, dimension, or number of components. <EM CLASS="FunctionName">
GRcreate</EM>
 does not actually write the image to the file; this occurs only when <EM CLASS="FunctionName">
GRendaccess</EM>
 is called. Thus, failing to call <EM CLASS="FunctionName">
GRendaccess</EM>
 properly will cause a loss of data.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-31056"></A>The buffer <EM CLASS="VarName">
name</EM>
 contains the name of the image; it must not exceed <EM CLASS="DefName">
H4_MAX_GR_NAME </EM>
(or<EM CLASS="DefName">
 256</EM>
). The parameter <EM CLASS="VarName">
n_comps</EM>
 specifies the number of pixel components in the raster image; it must have a value of at least 1. The parameter <EM CLASS="VarName">
data_type</EM>
 specifies the data type of the image data; it can be any of the data types supported by the HDF library. The HDF supported data type are defined in the header file “hntdefs.h” and listed in <EM CLASS="Synopsis2">
<A HREF="UG_html-2.htm#50593872_13047" CLASS="XRef">Standard HDF Data Types and Flags</A></EM>
.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-43560"></A>The parameter <EM CLASS="VarName">
interlace_mode</EM>
 specifies the interlacing in which the raster image is to be written; it can be set to either <EM CLASS="DefName">
MFGR_INTERLACE_PIXEL</EM>
<A NAME="50593878_marker-43561"></A> (or <EM CLASS="DefName">
0</EM>
), <EM CLASS="DefName">
MFGR_INTERLACE_LINE</EM>
<A NAME="50593878_marker-43562"></A> (or<EM CLASS="DefName">
 1</EM>
), or <EM CLASS="DefName">
MFGR_INTERLACE_COMPONENT</EM>
<A NAME="50593878_marker-43563"></A> (or<EM CLASS="DefName">
 2</EM>
). These definitions respectively correspond to pixel interlacing, line interlacing, and component interlacing. The first two interlacing modes are illustrated for the instance of 24-bit pixel representation in <A HREF="UG_html-7.htm#50593877_17407" CLASS="XRef">RGB Interlace Format for 24-Bit Raster Images</A> of <A HREF="UG_html-7.htm#50593877_18201" CLASS="XRef">24-bit is it Raster Images (DF24 API)</A>.  Component interlacing, as the name implies, describes interlacing raster data by color component.  Note that images created with the GR interface are actually written to disk in pixel interlace mode; any user-specified interlace mode is stored in the file with the image and the image is automatically converted to that mode when it is read with a GR interface function.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-43762"></A>The parameter <EM CLASS="VarName">
dim_sizes</EM>
 specifies the size of the two dimensions of the image. The dimension sizes must be specified; their values must be at least 1.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-36876"></A><EM CLASS="FunctionName">
GRcreate</EM>
 returns the value of the raster image identifier if successful or <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
) otherwise. The parameters for <EM CLASS="FunctionName">
GRstart</EM>
, <EM CLASS="FunctionName">
GRselect</EM>
, and <EM CLASS="FunctionName">
GRcreate</EM>
 are further defined in <A HREF="UG_html-8.htm#50593878_12133" CLASS="XRef">GRstart, GRselect, GRcreate, GRendaccess, and GRend, Parameter Lists</A>.</P>
</DIV>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-7736"></A>	8.5.2	<A NAME="50593878_27202"></A>Termin<A NAME="50593878_marker-22482"></A>ating Access to Images and Files: GRendaccess and GRend</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-7737"></A><EM CLASS="FunctionName">
GRendaccess</EM>
<A NAME="50593878_marker-22483"></A> disposes of the raster image identifier <EM CLASS="VarName">
ri_id</EM>
 and terminates access to the data set initiated by the corresponding call to <EM CLASS="FunctionName">
GRselect</EM>
 or <EM CLASS="FunctionName">
GRcreate</EM>
. The calling program must make one <EM CLASS="FunctionName">
GRendaccess</EM>
 call for every <EM CLASS="FunctionName">
GRselect</EM>
 or <EM CLASS="FunctionName">
GRcreate</EM>
 call made during its execution. Failing to call <EM CLASS="FunctionName">
GRendaccess</EM>
 for each call to <EM CLASS="FunctionName">
GRselect</EM>
 or <EM CLASS="FunctionName">
GRcreate</EM>
 may result in a loss of data.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-7744"></A><EM CLASS="FunctionName">
GRend</EM>
<A NAME="50593878_marker-22484"></A> disposes of the GR interface identifier <EM CLASS="VarName">
gr_id</EM>
 and terminates access to the GR interface initiated by the corresponding call to <EM CLASS="FunctionName">
GRstart</EM>
. The calling program must make one <EM CLASS="FunctionName">
GRend</EM>
 call for every <EM CLASS="FunctionName">
GRstart</EM>
 call made during its execution; failing to call <EM CLASS="FunctionName">
GRend</EM>
 for each <EM CLASS="FunctionName">
GRstart</EM>
 may result in a loss of data. </P>
<P CLASS="Body">
<A NAME="50593878_pgfId-35718"></A><EM CLASS="FunctionName">
GRendaccess</EM>
 and <EM CLASS="FunctionName">
GRend</EM>
 return <EM CLASS="DefName">
SUCCEED</EM>
 (or <EM CLASS="DefName">
0</EM>
) or <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
). The parameters of these routines are further defined in <A HREF="UG_html-8.htm#50593878_12133" CLASS="XRef">Table 8B</A>.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-37180"></A><EM CLASS="FunctionName">
Hclose</EM>
 terminates access to an HDF file and should only be called after <EM CLASS="FunctionName">
GRend</EM>
 has been called properly. Refer to <A HREF="UG_html-2.htm#50593872_13138" CLASS="XRef">HDF Fundamentals</A>, for a description of <EM CLASS="FunctionName">
Hclose</EM>
.</P>
<DIV>
<H6 CLASS="Table">
<A NAME="50593878_pgfId-7836"></A><DIV>
<IMG SRC="UG_html-51.gif" ALT="">
</DIV>
<A NAME="50593878_12133"></A>GR<A NAME="50593878_marker-22485"></A>start, GRse<A NAME="50593878_marker-22486"></A>lect, GRcr<A NAME="50593878_marker-31322"></A>eate, GR<A NAME="50593878_marker-52711"></A>endaccess, and <A NAME="50593878_marker-22487"></A>GRend, Parameter Lists</H6>
<TABLE>
<TR>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-8900"></A>Routine Name</P>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-29908"></A>[Return Type]</H6>
<P CLASS="TableHead">
<A NAME="50593878_pgfId-8901"></A>(FORTRAN-77)</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-8903"></A>Parameter</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-8907"></A>Parameter Type</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-8909"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-8915"></A>C</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-8917"></A>FORTRAN-77</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-8921"></A>GRstart</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-29909"></A>[int32]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-8922"></A>(mgstart)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-8924"></A>file_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-8926"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-8928"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-8930"></A>File identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="2" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-8932"></A>GRselect</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-29910"></A>[int32]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-8933"></A>(mgselct)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-8935"></A>gr_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-8937"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-8939"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-8941"></A>GR interface identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-8945"></A>ri_index</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-8947"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-8949"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-8951"></A>Position of the raster image within the file</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="6" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-31316"></A>GRcreate</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-31317"></A>[int32]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-31318"></A>(mgcreat)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-31268"></A>gr_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-31270"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-31272"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-31274"></A>GR interface identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-31276"></A>name</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-31278"></A>char *</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-31280"></A>character*(*)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-31282"></A>Name of the image</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-31284"></A>n_comps</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-31286"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-31288"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-31290"></A>Number of components in each pixel</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-31292"></A>data_type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-31294"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-31296"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-31298"></A>Data type of the pixel component</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-31300"></A>interlace_mode</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-31302"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-31304"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-31306"></A>Interlace mode to be used when writing to the data set</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-31308"></A>dim_sizes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-31310"></A>int32 [2]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-31312"></A>integer (2)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-31314"></A>Array defining the size of both dimensions</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-52726"></A>GRendaccess</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-52727"></A>[intn]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-52728"></A>(mgendac)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-52730"></A>ri_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-52732"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-52734"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-52736"></A>Raster image identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-8953"></A>GRend</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-29911"></A>[intn]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-8954"></A>(mgend)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-8956"></A>gr_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-8958"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-8960"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-8962"></A>GR interface identifier</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
</DIV>
<DIV>
<H5 CLASS="Heading2">
<A NAME="50593878_pgfId-48134"></A>	8.6	Writing Raster Images<DIV>
<IMG SRC="UG_html-50.gif" ALT="">
</DIV>
</H5>
<P CLASS="Body">
<A NAME="50593878_pgfId-44105"></A>A raster image can be written partially or entirely. Partial writing includes writing to a contiguous region of the image and writing to selected locations in the image according to patterns defined by the user. This section describes the routine <EM CLASS="FunctionName">
GRwriteimage</EM>
 and how it can write data to part of an image or to an entire image. The section also illustrates the concepts of compressing raster images and the use of external files to store image data. </P>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-44102"></A>	8.6.1	<A NAME="50593878_11596"></A>Writing Raster Images: GRwriteimage</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-43859"></A><EM CLASS="FunctionName">
GRwriteimage</EM>
<A NAME="50593878_marker-43858"></A> is used to either completely or partially fill an image array.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-32665"></A>Writing data to an image array involves the following steps:</P>
<DIV>
<H6 CLASS="FM1Step">
<A NAME="50593878_pgfId-9589"></A>Open a file and initialize the GR interface. </H6>
<OL>
<LI CLASS="Step">
<A NAME="50593878_pgfId-9590"></A>2.	Select an existing raster image or create a new one.</LI>
<LI CLASS="Step">
<A NAME="50593878_pgfId-9591"></A>3.	Write data to the image array.</LI>
<LI CLASS="Step">
<A NAME="50593878_pgfId-9592"></A>4.	Terminate access to the raster image.</LI>
<LI CLASS="Step">
<A NAME="50593878_pgfId-21133"></A>5.	Terminate access to the GR interface and close the file.</LI>
</OL>
<P CLASS="Body">
<A NAME="50593878_pgfId-9594"></A>The calling program must contain the following sequence of calls:</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-9595"></A><EM CLASS="syntaxLang">
C:</EM>
		file_id = Hopen(filename, access_mode, num_dds_block);</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-43816"></A>		gr_id = GRstart(file_id);</P>
<P CLASS="syntax-or-top">
<A NAME="50593878_pgfId-43832"></A>		ri_id = GRselect(gr_id, ri_index);</P>
<P CLASS="syntax-or-bot">
<A NAME="50593878_pgfId-43833"></A>	<EM CLASS="syntaxLang">
OR</EM>
	ri_id = GRcreate(gr_id, name, n_comps, number_type, interlace_mode, dim_sizes);	</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-9597"></A>		status = GRwriteimage(ri_id, start, stride, edges, data);</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-9598"></A>		status = GRendaccess(gr_id);</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-9599"></A>		status = GRend(ri_id);</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-9899"></A>		status = Hclose(file_id);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-9601"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	file_id = hopen(filename, access_mode, num_dds_block)</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-18847"></A>		gr_id = mgstart(file_id)</P>
<P CLASS="syntax-or-top">
<A NAME="50593878_pgfId-43844"></A>		ri_id = mgselct(gr_id, ri_index);</P>
<P CLASS="syntax-or-bot">
<A NAME="50593878_pgfId-34503"></A>	<EM CLASS="syntaxLang">
OR</EM>
	ri_id = mgcreat(gr_id, name, n_comps, number_type, interlace_mode, dim_sizes);</P>
<P CLASS="syntax-or-top">
<A NAME="50593878_pgfId-34505"></A>		status = mgwrimg(ri_id, start, stride, edges, data)</P>
<P CLASS="syntax-or-bot">
<A NAME="50593878_pgfId-30862"></A>	<EM CLASS="syntaxLang">
OR</EM>
	status = mgwrcmg(ri_id, start, stride, edges, data) </P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-9604"></A>		status = mgendac(ri_id)</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-9926"></A>		status = mgend(gr_id)</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-9927"></A>		status = hclose(file_id)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-32644"></A>As with SD arrays, whole raster images, subsamples, and slabs can be written. The data to be written is defined by the values of the parameters <EM CLASS="VarName">
start</EM>
, <EM CLASS="VarName">
stride</EM>
, and <EM CLASS="VarName">
edges</EM>
, which correspond to the coordinate location of the data origin, number of values to be skipped along each dimension during write operation, and number of elements to be written along each dimension.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-32652"></A>The array <EM CLASS="VarName">
start</EM>
 specifies the starting location of the data to be written. Valid values of each element in the array <EM CLASS="VarName">
start</EM>
 are <EM CLASS="DefName">
0</EM>
 to the size of the corresponding raster image dimension - 1. The first element of the array <EM CLASS="VarName">
start</EM>
 specifies an offset from the beginning of the array <EM CLASS="VarName">
data</EM>
 along the fastest-changing dimension, which is the second dimension in C and the first dimension in FORTRAN-77. The second element of the array <EM CLASS="VarName">
start</EM>
 specifies an offset from the beginning of the array <EM CLASS="VarName">
data</EM>
 along the second fastest-changing dimension, which is the first dimension in C and the second dimension in FORTRAN-77. For example, if the first value of the array <EM CLASS="VarName">
start</EM>
 is 2 and the second value is 3, the starting location of the data to be written is at the fourth row and third column in C, and at the third row and fourth column in FORTRAN-77. Note that the correspondence between elements in the array <EM CLASS="VarName">
start</EM>
 and the raster image dimensions in the GR interface is different from that in the SD interface. See <A HREF="UG_html-3.htm#50593873_13107" CLASS="XRef">Reading Data from an SDS Array: SDreaddata</A> on <EM CLASS="FunctionName">
SDreaddata</EM>
 for an example of this.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-32656"></A>The array <EM CLASS="VarName">
stride</EM>
 specifies the writing pattern along each dimension. For example, if one of the elements of the array <EM CLASS="VarName">
stride</EM>
 is 1, then every element along the corresponding dimension of the array <EM CLASS="VarName">
data</EM>
  will be written. If one of the elements of the <EM CLASS="VarName">
stride</EM>
 array is 2, then every other element along the corresponding dimension of the array <EM CLASS="VarName">
data</EM>
  will be written, and so on. The correspondence between elements of the array <EM CLASS="VarName">
stride</EM>
  and the dimensions of the array <EM CLASS="VarName">
data</EM>
 is the same as described above for the array <EM CLASS="VarName">
start</EM>
.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-9647"></A>Note that the FORTRAN-77 version of <EM CLASS="FunctionName">
GRwriteimage</EM>
 has two routines; <EM CLASS="FunctionName">
mgwrimg</EM>
 writes buffered numeric data and <EM CLASS="FunctionName">
mgwcimg</EM>
 writes buffered character data.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-22865"></A><EM CLASS="FunctionName">
GRwriteimage</EM>
 returns either <EM CLASS="DefName">
SUCCEED </EM>
(or <EM CLASS="DefName">
0</EM>
) or <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
). The parameters for <EM CLASS="FunctionName">
GRwriteimage</EM>
 are described in <A HREF="UG_html-8.htm#50593878_19628" CLASS="XRef">Table 8C</A>.</P>
</DIV>
<DIV>
<H6 CLASS="Table">
<A NAME="50593878_pgfId-47935"></A><DIV>
<IMG SRC="UG_html-51.gif" ALT="">
</DIV>
<A NAME="50593878_19628"></A>GRwrite<A NAME="50593878_marker-47858"></A>image Parameter List</H6>
<TABLE>
<TR>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-47861"></A>Routine Name</P>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-47862"></A>[Return Type]</H6>
<P CLASS="TableHead">
<A NAME="50593878_pgfId-47863"></A>(FORTRAN-77)</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-47865"></A>Parameter</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-47867"></A>Parameter Type</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-47871"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-47877"></A>C</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-47879"></A>FORTRAN-77</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="5" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-47883"></A>GRwriteimage</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-47884"></A>[intn]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-47885"></A>(mgwrimg/</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-47886"></A>mgwcimg)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-47888"></A>ri_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-47890"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-47892"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-47894"></A>Raster image identifier returned by GRcreate</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-47898"></A>start</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-47900"></A>int32 [2]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-47902"></A>integer (2)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-47904"></A>Array containing the x,y-coordinate location where the write will start for each dimension</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-47908"></A>stride</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-47910"></A>int32 [2]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-47912"></A>integer (2)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-47914"></A>Array containing the number of data locations the current location is to be moved forward before the next write</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-47918"></A>edges</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-47920"></A>int32 [2]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-47922"></A>integer (2)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-47924"></A>Array containing the number of data elements that will be written along each dimension</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-47928"></A>data</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-47930"></A>VOIDP</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-47932"></A>&lt;valid numeric data type&gt;(*)/</P>
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-52827"></A>character(*)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-47934"></A>Buffer for the image data to be written</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Example">
<A NAME="50593878_pgfId-47941"></A><DIV>
<IMG SRC="UG_html-51.gif" ALT="">
</DIV>
<A NAME="50593878_75625"></A>Creating and Writing a Raster Image</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-47942"></A>This example illustrates the use of the routines <EM CLASS="FunctionName">
Hopen</EM>
/<EM CLASS="FunctionName">
hopen</EM>
, <EM CLASS="FunctionName">
GRstart</EM>
/<EM CLASS="FunctionName">
mgstart</EM>
, <EM CLASS="FunctionName">
GRcreate</EM>
/<EM CLASS="FunctionName">
mgcreat</EM>
, <EM CLASS="FunctionName">
GRwriteimage</EM>
/<EM CLASS="FunctionName">
mgwrimg</EM>
, <EM CLASS="FunctionName">
GRendaccess</EM>
/<EM CLASS="FunctionName">
mgendac</EM>
, <EM CLASS="FunctionName">
GRend</EM>
/<EM CLASS="FunctionName">
mgend</EM>
, and <EM CLASS="FunctionName">
Hclose</EM>
/<EM CLASS="FunctionName">
hclose</EM>
 to create an HDF file and store a raster image in it.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-48329"></A>In this example, the program creates the HDF file called &quot;General_RImages.hdf&quot; and a raster image in the file. The image created is of size 5x10 and named &quot;Image Array 1&quot;, and has data of the int16 data type, 2 components, and interlace mode <EM CLASS="DefName">
MFGR_INTERLACE_PIXEL</EM>
. Then the program writes the image data, terminates access to the image and the GR interface, and closes the file.</P>
</DIV>
</DIV>
</DIV>
</DIV>
<DIV>
<H4 CLASS="Code-C-Title">
<A NAME="50593878_pgfId-126089"></A><DIV>
<IMG SRC="UG_html-53.gif" ALT="">
</DIV>
	C:		</H4>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126092"></A>#include &quot;hdf.h&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126183"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126184"></A>#define  FILE_NAME     &quot;General_RImages.hdf&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126185"></A>#define  IMAGE_NAME    &quot;Image Array 1&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126186"></A>#define  X_LENGTH      10    /* number of columns in the image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126187"></A>#define  Y_LENGTH      5     /* number of rows in the image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126188"></A>#define  N_COMPS       2     /* number of components in the image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126189"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126190"></A>main( ) </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126191"></A>{</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126192"></A>   /************************* Variable declaration **************************/</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126193"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126194"></A>   intn  status;         /* status for functions returning an intn */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126195"></A>   int32 file_id,        /* HDF file identifier */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126196"></A>         gr_id,          /* GR interface identifier */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126197"></A>         ri_id,          /* raster image identifier */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126198"></A>         start[2],       /* start position to write for each dimension */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126199"></A>         edges[2],       /* number of elements to be written </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126200"></A>                           along each dimension */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126201"></A>         dim_sizes[2],   /* dimension sizes of the image array */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126202"></A>         interlace_mode, /* interlace mode of the image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126203"></A>         data_type,      /* data type of the image data */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126204"></A>         i, j;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126205"></A>   int16 image_buf[Y_LENGTH][X_LENGTH][N_COMPS];</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126206"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126207"></A>   /********************** End of variable declaration **********************/</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126208"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126209"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126210"></A>   * Create and open the file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126211"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126212"></A>   file_id = Hopen (FILE_NAME, DFACC_CREATE, 0);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126213"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126214"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126215"></A>   * Initialize the GR interface.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126216"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126217"></A>   gr_id = GRstart (file_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126218"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126219"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126220"></A>   * Set the data type, interlace mode, and dimensions of the image.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126221"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126222"></A>   data_type = DFNT_INT16;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126223"></A>   interlace_mode = MFGR_INTERLACE_PIXEL;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126224"></A>   dim_sizes[0] = X_LENGTH;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126225"></A>   dim_sizes[1] = Y_LENGTH;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126226"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126227"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126228"></A>   * Create the raster image array.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126229"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126230"></A>   ri_id = GRcreate (gr_id, IMAGE_NAME, N_COMPS, data_type, </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126231"></A>                     interlace_mode, dim_sizes);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126232"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126233"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126234"></A>   * Fill the image data buffer with values.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126235"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126236"></A>   for (i = 0; i &lt; Y_LENGTH; i++)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126237"></A>   {</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126238"></A>      for (j = 0; j &lt; X_LENGTH; j++)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126239"></A>      {</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126240"></A>         image_buf[i][j][0] = (i + j) + 1;     /* first component */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126241"></A>         image_buf[i][j][1] = (i + j) + 1;     /* second component */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126242"></A>      }</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126243"></A>    }</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126244"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126245"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126246"></A>   * Define the size of the data to be written, i.e., start from the origin</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126247"></A>   * and go as long as the length of each dimension.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126248"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126249"></A>   start[0] = start[1] = 0;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126250"></A>   edges[0] = X_LENGTH;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126251"></A>   edges[1] = Y_LENGTH;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126252"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126253"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126254"></A>   * Write the data in the buffer into the image array.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126255"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126256"></A>   status = GRwriteimage(ri_id, start, NULL, edges, (VOIDP)image_buf);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126257"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126258"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126259"></A>   * Terminate access to the raster image and to the GR interface and, </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126260"></A>   * close the HDF file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126261"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126262"></A>   status = GRendaccess (ri_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126263"></A>   status = GRend (gr_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126264"></A>   status = Hclose (file_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126265"></A>}</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126266"></A>&nbsp;</P>
</DIV>
<DIV>
<H4 CLASS="Code-F-Title">
<A NAME="50593878_pgfId-126179"></A><DIV>
<IMG SRC="UG_html-53.gif" ALT="">
</DIV>
FORTRAN:	</H4>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-48427"></A>	      program create_raster_image</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126274"></A>      implicit none</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126275"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126276"></A>C     Parameter declaration</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126277"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126278"></A>      character*19 FILE_NAME</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126279"></A>      character*13 IMAGE_NAME</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126280"></A>      integer      X_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126281"></A>      integer      Y_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126282"></A>      integer      N_COMPS</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126283"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126284"></A>      parameter (FILE_NAME  = ’General_RImages.hdf’,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126285"></A>     +           IMAGE_NAME = ’Image Array 1’,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126286"></A>     +           X_LENGTH   = 10,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126287"></A>     +           Y_LENGTH   = 5,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126288"></A>     +           N_COMPS    = 2)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126289"></A>      integer DFACC_CREATE, DFNT_INT16, MFGR_INTERLACE_PIXEL</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126290"></A>      parameter (DFACC_CREATE = 4,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126291"></A>     +           DFNT_INT16   = 22,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126292"></A>     +           MFGR_INTERLACE_PIXEL = 0)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126293"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126294"></A>C     Function declaration</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126295"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126296"></A>      integer hopen, hclose</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126297"></A>      integer mgstart, mgcreat, mgwrimg, mgendac, mgend </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126298"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126299"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126300"></A>C**** Variable declaration *******************************************</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126301"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126302"></A>      integer status</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126303"></A>      integer file_id</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126304"></A>      integer gr_id, ri_id, num_type, interlace_mode</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126305"></A>      integer start(2), stride(2), edges(2), dimsizes(2)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126306"></A>      integer i, j, k</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126307"></A>      integer*2  image_buf(N_COMPS, X_LENGTH, Y_LENGTH) </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126308"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126309"></A>C**** End of variable declaration ************************************</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126310"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126311"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126312"></A>C     Create and open the file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126313"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126314"></A>      file_id = hopen(FILE_NAME, DFACC_CREATE, 0)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126315"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126316"></A>C     Initialize the GR interface.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126317"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126318"></A>      gr_id = mgstart(file_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126319"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126320"></A>C     Set the number type, interlace mode, and dimensions of the image.  </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126321"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126322"></A>      num_type = DFNT_INT16</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126323"></A>      interlace_mode = MFGR_INTERLACE_PIXEL</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126324"></A>      dimsizes(1) = X_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126325"></A>      dimsizes(2) = Y_lENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126326"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126327"></A>C     Create the raster image array. </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126328"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126329"></A>      ri_id = mgcreat(gr_id, IMAGE_NAME, N_COMPS, num_type,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126330"></A>     +                interlace_mode, dimsizes)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126331"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126332"></A>C     Fill the image data buffer with values. </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126333"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126334"></A>      do 30 i = 1, Y_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126335"></A>         do 20 j = 1, X_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126336"></A>            do 10 k = 1, N_COMPS</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126337"></A>               image_buf(k,j,i) = (i+j) - 1</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126338"></A>10          continue</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126339"></A>20       continue</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126340"></A>30    continue</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126341"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126342"></A>C     </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126343"></A>C     Define the size of the data to be written, i.e., start from the origin</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126344"></A>C     and go as long as the length of each dimension.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126345"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126346"></A>      start(1) = 0</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126347"></A>      start(2) = 0</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126348"></A>      edges(1) = X_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126349"></A>      edges(2) = Y_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126350"></A>      stride(1) = 1</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126351"></A>      stride(2) = 1</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126352"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126353"></A>C     Write the data in the buffer into the image array.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126354"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126355"></A>      status = mgwrimg(ri_id, start, stride, edges, image_buf)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126356"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126357"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126358"></A>C     Terminate access to the raster image and to the GR interface, </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126359"></A>C     and close the HDF file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126360"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126361"></A>      status = mgendac(ri_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126362"></A>      status = mgend(gr_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126363"></A>      status = hclose(file_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126364"></A>      end</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-126365"></A>&nbsp;</P>
<DIV>
<H6 CLASS="Example">
<A NAME="50593878_pgfId-57991"></A><DIV>
<IMG SRC="UG_html-51.gif" ALT="">
</DIV>
Modifying an Existing Raster Image</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-57992"></A>This example illustrates the use of the routines <EM CLASS="FunctionName">
GRselect</EM>
/<EM CLASS="FunctionName">
mgselct</EM>
 to obtain an existing raster image and <EM CLASS="FunctionName">
GRwrite</EM>
/<EM CLASS="FunctionName">
mgwrimg</EM>
 to modify image data.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-45627"></A>In this example, the program selects the only raster image in the file &quot;General_RImages.hdf&quot; created and written in Example 1, and modifies image data. The program also creates another raster image that is named &quot;Image Array 2&quot; and has 3 components with dimension size of 4x6, data type of <EM CLASS="DefName">
DFNT_CHAR8</EM>
, and interlace mode of <EM CLASS="DefName">
MFGR_INTERLACE_PIXEL</EM>
.</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="Code-C-Title">
<A NAME="50593878_pgfId-46044"></A><DIV>
<IMG SRC="UG_html-53.gif" ALT="">
</DIV>
C:		</H4>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-46789"></A>#include &quot;hdf.h&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53036"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53037"></A>#define  FILE_NAME    &quot;General_RImages.hdf&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53038"></A>#define  X1_LENGTH    5     /* number of columns in the first image </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53039"></A>                              being modified */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53040"></A>#define  Y1_LENGTH    2     /* number of rows in the first image </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53041"></A>                              being modified */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53042"></A>#define  N1_COMPS     2     /* number of components in the first image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53043"></A>#define  IMAGE1_NAME  &quot;Image Array 1&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53044"></A>#define  IMAGE2_NAME  &quot;Image Array 2&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53045"></A>#define  X2_LENGTH    6     /* number of columns in the second image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53046"></A>#define  Y2_LENGTH    4     /* number of rows in the second image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53047"></A>#define  N2_COMPS     3     /* number of components in the second image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53048"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53049"></A>main( ) </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53050"></A>{</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53051"></A>   /************************* Variable declaration **************************/</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53052"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53053"></A>   intn  status;         /* status for functions returning an intn */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53054"></A>   int32 file_id,        /* HDF file identifier */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53055"></A>         gr_id,          /* GR interface identifier */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53056"></A>         ri1_id,         /* raster image identifier */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53057"></A>         start1[2],      /* start position to write for each dimension */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53058"></A>         edges1[2],      /* number of elements to be written along</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53059"></A>                           each dimension */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53060"></A>         ri2_id,         /* raster image identifier */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53061"></A>         start2[2],      /* start position to write for each dimension */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53062"></A>         edges2[2],      /* number of elements to be written along </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53063"></A>                           each dimension */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53064"></A>         dims_sizes[2],  /* sizes of the two dimensions of the image array */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53065"></A>         data_type,      /* data type of the image data */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53066"></A>         interlace_mode; /* interlace mode of the image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53067"></A>   int16 i, j;           /* indices for the dimensions */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53068"></A>   int16 image1_buf[Y1_LENGTH][X1_LENGTH][N1_COMPS]; /* data of first image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53069"></A>   char  image2_buf[Y2_LENGTH][X2_LENGTH][N2_COMPS]; /* data of second image*/</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53070"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53071"></A>   /********************** End of variable declaration **********************/</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53072"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53073"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53074"></A>   * Open the HDF file for writing.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53075"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53076"></A>   file_id = Hopen (FILE_NAME, DFACC_WRITE, 0);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53077"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53078"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53079"></A>   * Initialize the GR interface.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53080"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53081"></A>   gr_id = GRstart (file_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53082"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53083"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53084"></A>   * Select the first raster image in the file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53085"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53086"></A>   ri1_id = GRselect (gr_id, 0);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53087"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53088"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53089"></A>   * Fill the first image data buffer with values.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53090"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53091"></A>   for (i = 0; i &lt; Y1_LENGTH; i++)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53092"></A>   {</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53093"></A>      for (j = 0; j &lt; X1_LENGTH; j++)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53094"></A>      {</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53095"></A>         image1_buf[i][j][0] = 0;  /* first component */ </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53096"></A>         image1_buf[i][j][1] = 0;  /* second component */ </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53097"></A>      }</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53098"></A>    }</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53099"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53100"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53101"></A>   * Define the size of the data to be written, i.e., start from the origin</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53102"></A>   * and go as long as the length of each dimension.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53103"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53104"></A>   start1[0] = start1[1] = 0;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53105"></A>   edges1[0] = X1_LENGTH;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53106"></A>   edges1[1] = Y1_LENGTH;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53107"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53108"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53109"></A>   * Write the data in the buffer into the image array.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53110"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53111"></A>   status = GRwriteimage (ri1_id, start1, NULL, edges1, (VOIDP)image1_buf);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53112"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53113"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53114"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53115"></A>   * Set the interlace mode and dimensions of the second image.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53116"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53117"></A>   data_type = DFNT_CHAR8;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53118"></A>   interlace_mode = MFGR_INTERLACE_PIXEL;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53119"></A>   dims_sizes[0] = X2_LENGTH;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53120"></A>   dims_sizes[1] = Y2_LENGTH;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53121"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53122"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53123"></A>   * Create the second image in the file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53124"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53125"></A>   ri2_id = GRcreate (gr_id, IMAGE2_NAME, N2_COMPS, data_type,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53126"></A>                                interlace_mode, dims_sizes);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53127"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53128"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53129"></A>   * Fill the second image data buffer with values.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53130"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53131"></A>   for (i = 0; i &lt; Y2_LENGTH; i++)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53132"></A>   {</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53133"></A>      for (j = 0; j &lt; X2_LENGTH; j++)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53134"></A>      {</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53135"></A>         image2_buf[i][j][0] = ’A’;     /* first component */ </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53136"></A>         image2_buf[i][j][1] = ’B’;     /* second component */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53137"></A>         image2_buf[i][j][2] = ’C’;     /* third component */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53138"></A>      }</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53139"></A>    }</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53140"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53141"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53142"></A>   * Define the size of the data to be written, i.e., start from the origin</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53143"></A>   * and go as long as the length of each dimension.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53144"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53145"></A>   for (i = 0; i &lt; 2; i++) {</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53146"></A>      start2[i] = 0;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53147"></A>      edges2[i] = dims_sizes[i];</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53148"></A>   }</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53149"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53150"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53151"></A>   * Write the data in the buffer into the second image array.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53152"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53153"></A>   status = GRwriteimage (ri2_id, start2, NULL, edges2, (VOIDP)image2_buf);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53154"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53155"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53156"></A>   * Terminate access to the raster images and to the GR interface, and</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53157"></A>   * close the HDF file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53158"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53159"></A>   status = GRendaccess (ri1_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53160"></A>   status = GRendaccess (ri2_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53161"></A>   status = GRend (gr_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53162"></A>   status = Hclose (file_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53163"></A>}</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53164"></A>&nbsp;</P>
</DIV>
<DIV>
<H4 CLASS="Code-F-Title">
<A NAME="50593878_pgfId-46180"></A><DIV>
<IMG SRC="UG_html-53.gif" ALT="">
</DIV>
FORTRAN:	</H4>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53304"></A>      program modify_image</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53319"></A>      implicit none</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53320"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53321"></A>C     Parameter declaration</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53322"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53323"></A>      character*19 FILE_NAME</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53324"></A>      character*13 IMAGE1_NAME</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53325"></A>      integer      X1_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53326"></A>      integer      Y1_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53327"></A>      integer      N1_COMPS</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53328"></A>      character*13 IMAGE2_NAME</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53329"></A>      integer      X2_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53330"></A>      integer      Y2_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53331"></A>      integer      N2_COMPS</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53332"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53333"></A>      parameter (FILE_NAME   = ’General_RImages.hdf’,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53334"></A>     +           IMAGE1_NAME = ’Image Array 1’,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53335"></A>     +           IMAGE2_NAME = ’Image Array 2’,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53336"></A>     +           X1_LENGTH   = 5,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53337"></A>     +           Y1_LENGTH   = 2,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53338"></A>     +           N1_COMPS    = 2,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53339"></A>     +           X2_LENGTH   = 6,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53340"></A>     +           Y2_LENGTH   = 4,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53341"></A>     +           N2_COMPS    = 3)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53342"></A>      integer DFACC_WRITE, DFNT_INT16, DFNT_CHAR8,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53343"></A>     +        MFGR_INTERLACE_PIXEL</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53344"></A>      parameter (DFACC_WRITE  = 2,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53345"></A>     +           DFNT_CHAR8   = 4,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53346"></A>     +           DFNT_INT16   = 22,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53347"></A>     +           MFGR_INTERLACE_PIXEL = 0)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53348"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53349"></A>C     Function declaration</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53350"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53351"></A>      integer hopen, hclose</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53352"></A>      integer mgstart, mgselct, mgcreat, mgwrimg, mgendac, mgend </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53353"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53354"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53355"></A>C**** Variable declaration *******************************************</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53356"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53357"></A>      integer status</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53358"></A>      integer file_id</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53359"></A>      integer gr_id, ri1_id, ri2_id, data_type, interlace_mode</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53360"></A>      integer start1(2), stride1(2), edges1(2)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53361"></A>      integer start2(2), stride2(2), edges2(2), dim_sizes(2)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53362"></A>      integer i, j, k</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53363"></A>      integer*2  image1_buf(N1_COMPS, X1_LENGTH, Y1_LENGTH) </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53364"></A>      character  image2_buf(N2_COMPS, X2_LENGTH, Y2_LENGTH)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53365"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53366"></A>C**** End of variable declaration ************************************</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53367"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53368"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53369"></A>C     Open the HDF file for writing.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53370"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53371"></A>      file_id = hopen(FILE_NAME, DFACC_WRITE, 0)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53372"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53373"></A>C     Initialize the GR interface.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53374"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53375"></A>      gr_id = mgstart(file_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53376"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53377"></A>C     Select the first raster image in the file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53378"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53379"></A>      ri1_id = mgselct(gr_id, 0)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53380"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53381"></A>C     Fill the buffer with values.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53382"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53383"></A>      do 20 i = 1, Y1_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53384"></A>         do 10 j = 1, X1_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53385"></A>               image1_buf(1,j,i) = 0 </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53386"></A>               image1_buf(2,j,i) = 0 </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53387"></A>10       continue</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53388"></A>20    continue</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53389"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53390"></A>C     Define the part of the data in the first image that will be overwritten</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53391"></A>C     with the new values from image1_buf.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53392"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53393"></A>      start1(1) = 0</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53394"></A>      start1(2) = 0</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53395"></A>      edges1(1) = X1_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53396"></A>      edges1(2) = Y1_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53397"></A>      stride1(1) = 1</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53398"></A>      stride1(2) = 1</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53399"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53400"></A>C     Write the data in the buffer into the image array.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53401"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53402"></A>      status = mgwrimg(ri1_id, start1, stride1, edges1, image1_buf)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53403"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53404"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53405"></A>C     Set the number type, interlace mode, and dimensions of the second image.  </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53406"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53407"></A>      data_type = DFNT_CHAR8</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53408"></A>      interlace_mode = MFGR_INTERLACE_PIXEL</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53409"></A>      dim_sizes(1) = X2_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53410"></A>      dim_sizes(2) = Y2_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53411"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53412"></A>C     Create the second image in the file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53413"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53414"></A>      ri2_id = mgcreat(gr_id, IMAGE2_NAME, N2_COMPS, data_type,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53415"></A>     +                interlace_mode, dim_sizes)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53416"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53417"></A>C     Fill the image data buffer with values. </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53418"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53419"></A>      do 60 i = 1, Y2_LENGTH </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53420"></A>         do 50 j = 1, X2_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53421"></A>            do 40 k = 1, N2_COMPS </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53422"></A>               image2_buf(k,j,i) = char(65 + k - 1) </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53423"></A>40          continue</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53424"></A>50       continue</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53425"></A>60    continue</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53426"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53427"></A>C     </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53428"></A>C     Define the size of the data to be written, i.e., start from the origin</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53429"></A>C     and go as long as the length of each dimension.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53430"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53431"></A>      start2(1) = 0</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53432"></A>      start2(2) = 0</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53433"></A>      edges2(1) =  dim_sizes(1)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53434"></A>      edges2(2) =  dim_sizes(2) </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53435"></A>      stride2(1) = 1</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53436"></A>      stride2(2) = 1</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53437"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53438"></A>C     Write the data in the buffer into the image array.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53439"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53440"></A>      status = mgwrimg(ri2_id, start2, stride2, edges2, image2_buf)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53441"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53442"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53443"></A>C     Terminate access to the raster images and to the GR interface,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53444"></A>C     and close the HDF file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53445"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53446"></A>      status = mgendac(ri1_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53447"></A>      status = mgendac(ri2_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53448"></A>      status = mgend(gr_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53449"></A>      status = hclose(file_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53450"></A>      end</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53451"></A>&nbsp;</P>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-47497"></A>	8.6.2	<A NAME="50593878_19774"></A>Com<A NAME="50593878_marker-47491"></A>pressing Raster Images: GRsetcompress</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-56352"></A>Images can be compressed using the routine <EM CLASS="FunctionName">
GRsetcompress</EM>
<A NAME="50593878_marker-47493"></A>. <EM CLASS="FunctionName">
GRsetcompress</EM>
 specifies that the image will contain compressed data after being written and supports all standard HDF compression algorithms. The syntax of the routine <EM CLASS="FunctionName">
GRsetcompress</EM>
 is as follows:</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-43920"></A><EM CLASS="syntaxLang">
C:</EM>
		status = GRsetcompress(ri_id, comp_type, c_info);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-43921"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	status = mgscompress(ri_id, comp_type, comp_prm)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-43922"></A>The compression method is specified by the parameter <EM CLASS="VarName">
comp_type</EM>
. Valid values of the parameter <EM CLASS="VarName">
comp_type</EM>
 are: </P>
<P CLASS="List10pt">
<A NAME="50593878_pgfId-196282"></A><EM CLASS="DefName">
COMP_CODE_NONE</EM>
 (or <EM CLASS="DefName">
0</EM>
) for no compression</P>
<P CLASS="List10pt">
<A NAME="50593878_pgfId-43924"></A><EM CLASS="DefName">
COMP_CODE_RLE</EM>
 (or <EM CLASS="DefName">
1</EM>
) for RLE run-length encoding</P>
<P CLASS="List10pt">
<A NAME="50593878_pgfId-43925"></A><EM CLASS="DefName">
COMP_CODE_SKPHUFF</EM>
 (or <EM CLASS="DefName">
3</EM>
) for Skipping Huffman compression</P>
<P CLASS="List10pt">
<A NAME="50593878_pgfId-43926"></A><EM CLASS="DefName">
COMP_CODE_DEFLATE</EM>
 (or <EM CLASS="DefName">
4</EM>
) for GZIP compression</P>
<P CLASS="List10pt">
<A NAME="50593878_pgfId-121961"></A><EM CLASS="DefName">
COMP_CODE_SZIP</EM>
 (or <EM CLASS="DefName">
5</EM>
) for Szip compression (not for Fortran)</P>
<P CLASS="List10pt">
<A NAME="50593878_pgfId-61610"></A><EM CLASS="DefName">
COMP_CODE_JPEG</EM>
 (or <EM CLASS="DefName">
7</EM>
) for JPEG compression</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-43927"></A>The compression parameters are specified by the parameter <EM CLASS="VarName">
c_info</EM>
 in C and the parameter <EM CLASS="VarName">
comp_prm</EM>
 in FORTRAN-77. The parameter <EM CLASS="VarName">
c_info</EM>
 has type <EM CLASS="VarName">
comp_info</EM>
 and contains algorithm-specific information for the library compression routines. The type <EM CLASS="VarName">
comp_info</EM>
 is described in the header file <EM CLASS="Code">
hcomp.h</EM>
 and in the reference manual page for <EM CLASS="FunctionName">
GRsetcompress</EM>
. Compression parameters are needed when Skipping Huffman, GZIP, Szip, and JPEG compression methods are applied.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-77053"></A>If <EM CLASS="VarName">
comp_type</EM>
 is set to <EM CLASS="DefName">
COMP_CODE_RLE</EM>
, the parameters <EM CLASS="VarName">
c_info</EM>
 and <EM CLASS="VarName">
comp_prm</EM>
 are not used; <EM CLASS="VarName">
c_info</EM>
 can be set to <EM CLASS="DefName">
NULL</EM>
 and <EM CLASS="VarName">
comp_prm</EM>
 can be undefined.  Note that, up to version 4.2.10, passing in <EM CLASS="DefName">
NULL</EM>
 for <EM CLASS="VarName">
c_info</EM>
 will cause failure.  This should be fixed in 4.2.11.  Also, note that <EM CLASS="DefName">
COMP_CODE_NONE</EM>
 will be an invalid value to <EM CLASS="FunctionName">
GRsetcompress</EM>
.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-77054"></A>If <EM CLASS="VarName">
comp_type</EM>
 is set to <EM CLASS="DefName">
COMP_CODE_SKPHUFF</EM>
, then the structure <EM CLASS="VarName">
skphuff</EM>
 in the union <EM CLASS="VarName">
comp_info</EM>
 in C (<EM CLASS="VarName">
comp_prm(1)</EM>
 in FORTRAN-77) must be provided with the size, in bytes, of the data elements.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-77055"></A>If <EM CLASS="VarName">
comp_type</EM>
 is set to <EM CLASS="DefName">
COMP_CODE_DEFLATE</EM>
, the deflate structure in the union <EM CLASS="VarName">
comp_info</EM>
 in C (<EM CLASS="VarName">
comp_prm(1)</EM>
 in FORTRAN-77) must be provided with the information about the compression effort.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-77056"></A>Note that, as of HDF 4.2.2, Szip was not supported in Fortran GR interface yet.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-125049"></A><EM CLASS="FunctionName">
GRsetcompress</EM>
 returns either <EM CLASS="DefName">
SUCCEED</EM>
 (or <EM CLASS="DefName">
0</EM>
) or <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
). The <EM CLASS="FunctionName">
GRsetcompress</EM>
 parameters are further described in <A HREF="UG_html-8.htm#50593878_34560" CLASS="XRef">Table 8D</A>.</P>
</DIV>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-125068"></A>	8.6.3	Setting<A NAME="50593878_marker-125067"></A> I/O Access Type for a Raster Image: GRsetaccesstype</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-125099"></A><EM CLASS="FunctionName">
GRsetaccesstype</EM>
<A NAME="50593878_marker-125098"></A> sets the access type to be either serial or parallel I/O for the raster image specified by ri_id.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-125070"></A>The syntax of the routine <EM CLASS="FunctionName">
GRsetaccesstype</EM>
 is as follows:</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-125040"></A><EM CLASS="syntaxLang">
C:</EM>
		status = GRsetaccesstype(ri_id, access_type);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-125041"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	status = mgsactp(ri_id, access_type)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-125033"></A>The access type is specified by the parameter <EM CLASS="VarName">
access_type</EM>
 and its valid values are <EM CLASS="DefName">
DFACC_SERIAL</EM>
 (or <EM CLASS="DefName">
1</EM>
), <EM CLASS="DefName">
DFACC_PARALLEL </EM>
(or <EM CLASS="DefName">
11</EM>
), and <EM CLASS="DefName">
DFACC_DEFAULT</EM>
 (or <EM CLASS="DefName">
0</EM>
.)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-125136"></A><EM CLASS="FunctionName">
GRsetaccesstype</EM>
 returns either <EM CLASS="DefName">
SUCCEED</EM>
 (or <EM CLASS="DefName">
0</EM>
) or <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
). The <EM CLASS="FunctionName">
GRsetaccesstype</EM>
 parameters are further described in <A HREF="UG_html-8.htm#50593878_34560" CLASS="XRef">Table 8D</A>.</P>
<DIV>
<H6 CLASS="Table">
<A NAME="50593878_pgfId-47095"></A><DIV>
<IMG SRC="UG_html-51.gif" ALT="">
</DIV>
<A NAME="50593878_34560"></A>GRset<A NAME="50593878_marker-47094"></A>compress and GRsetacc<A NAME="50593878_marker-125510"></A>esstype Parameter List</H6>
<TABLE>
<TR>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-47149"></A>Routine Name</P>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-47150"></A>[Return Type]</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-55708"></A>(FORTRAN-77)</H6>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-47152"></A>Parameter</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-55686"></A>Parameter Type</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-47156"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-55678"></A>C</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-55688"></A>FORTRAN-77</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="4" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-47166"></A>GRsetcompress</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-125489"></A>[intn]</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-55703"></A>(mgscompress)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-47170"></A>ri_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-55680"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-55690"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-47174"></A>Raster image identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-47178"></A>comp_type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-55682"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-55692"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-47182"></A>Compression method</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-47186"></A>c_info</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-55684"></A>comp_info*</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-55694"></A>N/A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-47190"></A>Pointer to compression information structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-55649"></A>comp_prm</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-55651"></A>N/A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-55698"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-55658"></A>Compression parameters array</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="2" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-125179"></A>GRsetaccesstype</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-125192"></A>[intn]</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-125181"></A>(mgsactp)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125183"></A>ri_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125185"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125187"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-125189"></A>Raster image identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125171"></A>access_type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125173"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125175"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-125177"></A>I/O access type</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-47254"></A>	8.6.4	<A NAME="50593878_13823"></A>Exter<A NAME="50593878_marker-47253"></A>nal File Operations Using the GR Interface</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-77078"></A>An <EM CLASS="Definition">
external image array</EM>
 is one that is stored in a file that is not the file containing the metadata for the image. The HDF file containing the metadata is known as the primary HDF file; the file containing the external image array is known as an <EM CLASS="Definition">
external file</EM>
. The concept of externally stored data is described in <EM CLASS="Funct-Call-Body">
<A HREF="UG_html-3.htm#50593873_13938" CLASS="XRef">Scientific Data Sets (SD API)</A></EM>
. The GR interface supports the same external file functionality as the SD interface.</P>
<DIV>
<H6 CLASS="Heading4">
<A NAME="50593878_pgfId-44003"></A>	8.6.4.1	<A NAME="50593878_10019"></A>Creatin<A NAME="50593878_marker-44002"></A>g a Raster Image in an External File: GRsetexternalfile</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-44004"></A>Creating an image with the data stored in an external file involves the same general steps as with the SD interface:</P>
<DIV>
<H6 CLASS="FM1Step">
<A NAME="50593878_pgfId-44005"></A>Create the image array.</H6>
<OL>
<LI CLASS="Step">
<A NAME="50593878_pgfId-44006"></A>2.	Specify that an external data file is to be used.</LI>
<LI CLASS="Step">
<A NAME="50593878_pgfId-44007"></A>3.	Write data to the image array.</LI>
<LI CLASS="Step">
<A NAME="50593878_pgfId-44008"></A>4.	Terminate access to the image. </LI>
</OL>
<P CLASS="Body">
<A NAME="50593878_pgfId-60912"></A>To create a data set containing image array stored in an external file, the calling program must make the following calls.</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-60913"></A><EM CLASS="syntaxLang">
C:</EM>
		ri_id = GRcreate(gr_id, name, n_comps, data_type, interlace_mode, dim_sizes);</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-44011"></A>		status = GRsetexternalfile(ri_id, filename, offset);</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-44012"></A>		status = GRwriteimage(ri_id, start, stride, edges, image_data);</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-44013"></A>		status = GRendaccess(ri_id);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-44014"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	ri_id = mgcreat(gr_id, name, n_comps, data_type, interlace_mode, dim_sizes)</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-44015"></A>		status = mgsxfil(ri_id, filename, offset)</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-44016"></A>		status = mgwrimg(ri_id, start, stride, edges, image_data)</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-44017"></A>		status = mgendac(ri_id)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-44019"></A><EM CLASS="FunctionName">
GRsetexternalfile</EM>
<A NAME="50593878_marker-44018"></A> marks the image identified by the parameter <EM CLASS="VarName">
ri_id</EM>
 as one whose data is to be written to an external file. The parameter <EM CLASS="VarName">
filename</EM>
 is the name of the external file, and the parameter <EM CLASS="VarName">
offset</EM>
 specifies the number of bytes from the beginning of the external file to the location where the first byte of data will be written.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-44020"></A><EM CLASS="FunctionName">
GRsetexternalfile</EM>
 can only be called once per data set. If a file with the same name as <EM CLASS="VarName">
filename</EM>
 exists in the current directory, HDF will use it as the external file. If the file does not exist, HDF will create one. Once the name of the external file is specified, it is impossible to change it without breaking the association between the raster image and its data.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-44021"></A>Use caution when writing to existing files because the routine <EM CLASS="FunctionName">
GRwriteimage</EM>
 begins its write at the specified offset without checking whether existing data is being overwritten. When different data sets have arrays being stored the same external file, the calling program is responsible for avoiding any overlap between them.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-55611"></A><EM CLASS="FunctionName">
GRsetexternalfile</EM>
 returns either <EM CLASS="DefName">
SUCCEED</EM>
 (or <EM CLASS="DefName">
0</EM>
) or <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
). The parameters of <EM CLASS="FunctionName">
GRsetexternalfile</EM>
 are further defined in <A HREF="UG_html-8.htm#50593878_17771" CLASS="XRef">Table 8E</A>.</P>
</DIV>
<DIV>
<H6 CLASS="Table">
<A NAME="50593878_pgfId-44083"></A><DIV>
<IMG SRC="UG_html-51.gif" ALT="">
</DIV>
<A NAME="50593878_17771"></A>GRsetex<A NAME="50593878_marker-44027"></A>ternalfile Parameter List</H6>
<TABLE>
<TR>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-44030"></A>Routine Name</P>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-44031"></A>[Return Type]</H6>
<P CLASS="TableHead">
<A NAME="50593878_pgfId-44032"></A>(FORTRAN-77)</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-44034"></A>Parameter</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-44036"></A>Parameter Type</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-44040"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-44046"></A>C</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-44048"></A>FORTRAN-77</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="3" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-44052"></A>GRsetexternalfile</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-44053"></A>[intn]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-44054"></A>(mgsxfil)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-44056"></A>ri_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-44058"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-44060"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-44062"></A>Raster image identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-44066"></A>filename</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-44068"></A>char *</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-44070"></A>character*(*)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-44072"></A>Name of the external file</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-44076"></A>offset</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-44078"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-44080"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-44082"></A>Offset in bytes from the beginning of the external file to the image data</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading4">
<A NAME="50593878_pgfId-44085"></A>	8.6.4.2	Moving Raster Images to an External File</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-44086"></A>Images can be moved from the primary HDF file to an external file. To do so requires the following steps:</P>
<DIV>
<H6 CLASS="FM1Step">
<A NAME="50593878_pgfId-44087"></A>Select the image.</H6>
<OL>
<LI CLASS="Step">
<A NAME="50593878_pgfId-44088"></A>2.	Specify the external data file.</LI>
<LI CLASS="Step">
<A NAME="50593878_pgfId-44089"></A>3.	Terminate access to the image. </LI>
</OL>
<P CLASS="Body">
<A NAME="50593878_pgfId-44090"></A>The calling program must make the following calls:</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-44091"></A><EM CLASS="syntaxLang">
C:</EM>
		ri_id = GRselect(gr_id, ri_index);</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-44092"></A>		status = GRsetexternalfile(ri_id, filename, offset);</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-44093"></A>		status = GRendaccess(ri_id);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-54863"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	ri_id = mgselct(gr_id, ri_index);</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-54873"></A>		status = mgsxfil(ri_id, filename, offset)</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-54865"></A>		status = mgendac(ri_id);</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-44094"></A>When <EM CLASS="FunctionName">
GRsetexternalfile</EM>
 is used in conjunction with <EM CLASS="FunctionName">
GRselect</EM>
, it will immediately write the existing data to the external file; any data in the external file that occupies the space reserved for the external array will be overwritten as a result of this operation. A data set can only be moved to an external file once. </P>
<P CLASS="Body">
<A NAME="50593878_pgfId-44095"></A>During the operation, the data is written to the external file as a contiguous stream regardless of how it is stored in the primary file. Because data is moved “as is,” any unwritten locations in the data set are preserved in the external file. Subsequent read and write operations performed on the data set will access the external file.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H5 CLASS="Heading2">
<A NAME="50593878_pgfId-10393"></A>	8.7	Reading Raster Images<DIV>
<IMG SRC="UG_html-50.gif" ALT="">
</DIV>
</H5>
<P CLASS="Body">
<A NAME="50593878_pgfId-44147"></A>Image array data can be read as an entire array or as a subsample of the array. Raster image data is read from an external file in the same way that it is read from a primary file; whether the image array is stored in an external file is transparent to the user. This section describes how <EM CLASS="FunctionName">
GRreadimage</EM>
 is used to read an entire image and part of an image. The section also describes the routine <EM CLASS="FunctionName">
GRreqimageil</EM>
 that sets the interlacing for reading image data.</P>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-44146"></A>	8.7.1	<A NAME="50593878_24692"></A>Reading Data from an Image<A NAME="50593878_marker-22505"></A>: GRreadimage</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-10394"></A>Reading data subsamples from an image array involves the following steps:</P>
<DIV>
<H6 CLASS="FM1Step">
<A NAME="50593878_pgfId-10395"></A>Select a data set. </H6>
<OL>
<LI CLASS="Step">
<A NAME="50593878_pgfId-10397"></A>2.	Read data from the image array.</LI>
<LI CLASS="Step">
<A NAME="50593878_pgfId-10398"></A>3.	Terminate access to the data set. </LI>
</OL>
<P CLASS="Body">
<A NAME="50593878_pgfId-10400"></A>To read data from an image array, the calling program must contain the following function calls:</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-10401"></A><EM CLASS="syntaxLang">
C:</EM>
		ri_id = GRselect(gr_id, ri_index);</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-10403"></A>		status = GRreadimage(ri_id, start, stride, edges, data);</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-10404"></A>		status = GRendaccess(ri_id);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-33786"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	ri_id = mgselct(gr_id, ri_index)</P>
<P CLASS="syntax-or-top">
<A NAME="50593878_pgfId-10409"></A>		status = mgrdimg(ri_id, start, stride, edges, data)</P>
<P CLASS="syntax-or-bot">
<A NAME="50593878_pgfId-34526"></A>	<EM CLASS="syntaxLang">
OR</EM>
	status = mgrcimg(ri_id, start, stride, edges, data)</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-10410"></A>		status = mgendac(gr_id)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-34551"></A><EM CLASS="FunctionName">
GRreadimage</EM>
<A NAME="50593878_marker-34550"></A> can be used to read either an entire image or a subsample of the image. The <EM CLASS="VarName">
ri_id </EM>
argument is the raster image identifier returned by <EM CLASS="FunctionName">
GRselect</EM>
. As with <EM CLASS="FunctionName">
GRwriteimage</EM>
, the arguments <EM CLASS="VarName">
start</EM>
, <EM CLASS="VarName">
stride</EM>
, and <EM CLASS="VarName">
edges</EM>
 respectively describe the starting location for the read operation, the number of locations the current image array location will be moved forward after each read, and the length of each dimension to be read. Refer to <A HREF="UG_html-8.htm#50593878_11596" CLASS="XRef">Writing Raster Images: GRwriteimage</A> for detailed descriptions of the parameters <EM CLASS="VarName">
start</EM>
, <EM CLASS="VarName">
stride</EM>
, and <EM CLASS="VarName">
edges</EM>
. If the image array is smaller than the <EM CLASS="VarName">
data</EM>
 argument array, the amount of data read will be limited to the maximum size of the image array. </P>
<P CLASS="Body">
<A NAME="50593878_pgfId-22880"></A>Note that the FORTRAN-77 version of <EM CLASS="FunctionName">
GRreadimage</EM>
 has two routines; <EM CLASS="FunctionName">
mgrdimg</EM>
 reads numeric image data and <EM CLASS="FunctionName">
mgrcimg</EM>
 reads character image data.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-22881"></A><EM CLASS="FunctionName">
GRreadimage</EM>
 returns either <EM CLASS="DefName">
SUCCEED</EM>
 (or <EM CLASS="DefName">
0</EM>
) or <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
). The parameters for <EM CLASS="FunctionName">
GRreadimage</EM>
 are further defined in <A HREF="UG_html-8.htm#50593878_37212" CLASS="XRef">GRreadimage and GRreqimageil Parameter Lists</A>.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-12096"></A>	8.7.2	<A NAME="50593878_26886"></A>Settin<A NAME="50593878_marker-22513"></A>g the Interlace Mode for an Image Read: GRreqimageil</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-35894"></A>The <EM CLASS="FunctionName">
GRreqimageil</EM>
 routine sets the interlace mode for the next image read. The syntax of this routine is as follows:</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-37321"></A><EM CLASS="syntaxLang">
C:</EM>
		status = GRreqimageil(ri_id, interlace_mode);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-37322"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	status = mgrimil(ri_id, interlace_mode)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-37317"></A><EM CLASS="FunctionName">
GRreqimageil</EM>
 can be called at any time before the read operation and takes two parameters, <EM CLASS="VarName">
ri_id</EM>
 and <EM CLASS="VarName">
interlace_mode</EM>
. The parameter <EM CLASS="VarName">
ri_id</EM>
 is the raster image identifier returned by the <EM CLASS="FunctionName">
GRselect</EM>
 routine and the parameter <EM CLASS="VarName">
interlace_mode</EM>
 specifies the interlace mode that will be in effect for the image read operation. Refer to <A HREF="UG_html-8.htm#50593878_19873" CLASS="XRef">Accessing Images and Files: GRstart, GRselect, and GRcreate</A> for a description of the GR interlace modes.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-35888"></A><EM CLASS="FunctionName">
GRreqimagetil</EM>
 may be called more than once; the interlace mode setting specified by the last call to the routine will be used for the next read operation.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-35887"></A><EM CLASS="FunctionName">
GRreqimagetil</EM>
 returns either <EM CLASS="DefName">
SUCCEED</EM>
 (or <EM CLASS="DefName">
0</EM>
) or <EM CLASS="DefName">
FAIL </EM>
(or <EM CLASS="DefName">
-1</EM>
). The parameters of this routine are further defined in <A HREF="UG_html-8.htm#50593878_37212" CLASS="XRef">Table 8F</A>.</P>
<DIV>
<H6 CLASS="Table">
<A NAME="50593878_pgfId-35874"></A><DIV>
<IMG SRC="UG_html-51.gif" ALT="">
</DIV>
<A NAME="50593878_37212"></A>GRre<A NAME="50593878_marker-35774"></A>adimage and GRreqima<A NAME="50593878_marker-35775"></A>geil Parameter Lists</H6>
<TABLE>
<TR>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-35778"></A>Routine Name </P>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-35779"></A>[Return Type]</H6>
<P CLASS="TableHead">
<A NAME="50593878_pgfId-35780"></A>(FORTRAN-77)</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-35782"></A>Parameter</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-35784"></A>Parameter Type</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-35788"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-35794"></A>C</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-35796"></A>FORTRAN-77</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="5" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-35800"></A>GRreadimage</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-35801"></A>[intn]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-35802"></A>(mgrdimg/</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-35803"></A>mgrcimg)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35805"></A>ri_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35807"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35809"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-35811"></A>Raster image identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35815"></A>start</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35817"></A>int32[2]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35819"></A>integer (2)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-35821"></A>Array containing the starting read coordinates</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35825"></A>stride</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35827"></A>int32[2]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35829"></A>integer (2)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-35831"></A>Array specifying the interval between the values that will be read along each dimension</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35835"></A>edges</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35837"></A>int32[2]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35839"></A>integer (2)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-35841"></A>Array containing the number of data elements that will be read along each dimension</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35845"></A>data</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35847"></A>VOIDP</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35849"></A>&lt;valid numeric data type&gt;(*)/character*(*)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-35851"></A>Buffer for the  image data to be read</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="2" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-35853"></A>GRreqimageil</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-35854"></A>[intn]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-35855"></A>(mgrimil)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35857"></A>ri_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35859"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35861"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-35863"></A>Raster image identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35867"></A>interlace_mode</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35869"></A>intn</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35871"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-35873"></A>Interlace mode for the next image read operation</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Example">
<A NAME="50593878_pgfId-34068"></A><DIV>
<IMG SRC="UG_html-51.gif" ALT="">
</DIV>
Reading a Raster Image.</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-48529"></A>This example illustrates the use of the routine <EM CLASS="FunctionName">
GRreadimage/mgrdimg</EM>
 to read an image and its subsets.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-48532"></A>In this example, the program reads the image written by Example 1 and modified by Example 2 in the file &quot;General_RImages.hdf&quot;. Recall that this image has two components and has 5 rows and 10 columns. The program first reads the entire image, then reads a subset of the image, 3 rows and 2 columns starting at the 2nd row and the 4th column, and finally reads the image skipping all the even rows and all the odd columns.  Reading patterns are applied to all components.</P>
</DIV>
</DIV>
</DIV>
</DIV>
<DIV>
<H4 CLASS="Code-C-Title">
<A NAME="50593878_pgfId-23906"></A><DIV>
<IMG SRC="UG_html-53.gif" ALT="">
</DIV>
C:		</H4>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-49174"></A>#include &quot;hdf.h&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53550"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53551"></A>#define  FILE_NAME       &quot;General_RImages.hdf&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53552"></A>#define  N_COMPS         2</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53553"></A>#define  X_LENGTH        10   /* number of columns of the entire image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53554"></A>#define  Y_LENGTH        5    /* number of rows of the entire image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53555"></A>#define  PART_COLS       2    /* number of columns read for partial image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53556"></A>#define  PART_ROWS       3    /* number of rows read for partial image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53557"></A>#define  SKIP_COLS       5    /* number of columns read for skipped image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53558"></A>#define  SKIP_ROWS       3    /* number of rows read for skipped image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53559"></A>#define  COLS_PART_START 3    /* starting column to read partial image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53560"></A>#define  ROWS_PART_START 1    /* starting row to read partial image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53561"></A>#define  COLS_SKIP_START 1    /* starting column to read skipped image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53562"></A>#define  ROWS_SKIP_START 0    /* starting row to read skipped image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53563"></A>#define  N_STRIDES       2    /* number of elements to skip on each dim. */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53564"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53565"></A>main( )</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53566"></A>{</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53567"></A>   /************************* Variable declaration **************************/</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53568"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53569"></A>   intn  status;        /* status for functions returning an intn */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53570"></A>   int32 index;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53571"></A>   int32 file_id, gr_id, ri_id,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53572"></A>         start[2],      /* start position to write for each dimension */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53573"></A>         edges[2],      /* number of elements to bewritten along </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53574"></A>                           each dimension */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53575"></A>         stride[2],     /* number of elements to skip on each dimension */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53576"></A>         dim_sizes[2];  /* dimension sizes of the image array */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53577"></A>   int16 entire_image[Y_LENGTH][X_LENGTH][N_COMPS],</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53578"></A>         partial_image[PART_ROWS][PART_COLS][N_COMPS],</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53579"></A>         skipped_image[SKIP_ROWS][SKIP_COLS][N_COMPS];</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53580"></A>   int32 i, j;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53581"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53582"></A>   /********************** End of variable declaration **********************/</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53583"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53584"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53585"></A>   * Open the HDF file for reading.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53586"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53587"></A>   file_id = Hopen (FILE_NAME, DFACC_READ, 0);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53588"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53589"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53590"></A>   * Initialize the GR interface.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53591"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53592"></A>   gr_id = GRstart (file_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53593"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53594"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53595"></A>   * Select the first raster image in the file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53596"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53597"></A>   ri_id = GRselect (gr_id, 0);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53598"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53599"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53600"></A>   * Define the size of the data to be read, i.e., start from the origin </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53601"></A>   * and go as long as the length of each dimension.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53602"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53603"></A>   start[0] = start[1] = 0;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53604"></A>   edges[0] = X_LENGTH;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53605"></A>   edges[1] = Y_LENGTH;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53606"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53607"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53608"></A>   * Read the data from the raster image array.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53609"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53610"></A>   status = GRreadimage (ri_id, start, NULL, edges, (VOIDP)entire_image);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53611"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53612"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53613"></A>   * Display only the first component of the image since the two components </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53614"></A>   * have the same data in this example.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53615"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53616"></A>   printf (&quot;First component of the entire image:\n&quot;);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53617"></A>   for (i = 0; i &lt; Y_LENGTH; i++)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53618"></A>   {</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53619"></A>      for (j = 0; j &lt; X_LENGTH; j++)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53620"></A>         printf (&quot;%d &quot;, entire_image[i][j][0]);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53621"></A>      printf (&quot;\n&quot;);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53622"></A>   }</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53623"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53624"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53625"></A>   * Define the size of the data to be read.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53626"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53627"></A>   start[0] = COLS_PART_START;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53628"></A>   start[1] = ROWS_PART_START;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53629"></A>   edges[0] = PART_COLS;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53630"></A>   edges[1] = PART_ROWS;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53631"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53632"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53633"></A>   * Read a subset of the raster image array.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53634"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53635"></A>   status = GRreadimage (ri_id, start, NULL, edges, (VOIDP)partial_image);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53636"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53637"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53638"></A>   * Display the first component of the read sample.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53639"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53640"></A>   printf (&quot;\nThree rows &amp; two cols at 2nd row and 4th column&quot;);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53641"></A>   printf (&quot; of the first component:\n&quot;);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53642"></A>   for (i = 0; i &lt; PART_ROWS; i++)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53643"></A>   {</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53644"></A>      for (j = 0; j &lt; PART_COLS; j++)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53645"></A>         printf (&quot;%d &quot;, partial_image[i][j][0]);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53646"></A>      printf (&quot;\n&quot;);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53647"></A>   }</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53648"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53649"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53650"></A>   * Define the size and the pattern to read the data.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53651"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53652"></A>   start[0] = COLS_SKIP_START;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53653"></A>   start[1] = ROWS_SKIP_START;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53654"></A>   edges[0] = SKIP_COLS;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53655"></A>   edges[1] = SKIP_ROWS;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53656"></A>   stride[0] = stride[1] = N_STRIDES;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53657"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53658"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53659"></A>   * Read all the odd rows and even columns of the image.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53660"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53661"></A>   status = GRreadimage (ri_id, start, stride, edges, (VOIDP)skipped_image);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53662"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53663"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53664"></A>   * Display the first component of the read sample.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53665"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53666"></A>   printf (&quot;\nAll odd rows and even columns of the first component:\n&quot;);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53667"></A>   for (i = 0; i &lt; SKIP_ROWS; i++)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53668"></A>   {</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53669"></A>      for (j = 0; j &lt; SKIP_COLS; j++)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53670"></A>         printf (&quot;%d &quot;, skipped_image[i][j][0]);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53671"></A>      printf (&quot;\n&quot;);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53672"></A>   }</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53673"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53674"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53675"></A>   * Terminate access to the raster image and to the GR interface, and</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53676"></A>   * close the HDF file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53677"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53678"></A>   status = GRendaccess (ri_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53679"></A>   status = GRend (gr_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53680"></A>   status = Hclose (file_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53681"></A>}</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53682"></A>&nbsp;</P>
</DIV>
<DIV>
<H4 CLASS="Code-F-Title">
<A NAME="50593878_pgfId-48736"></A><DIV>
<IMG SRC="UG_html-53.gif" ALT="">
</DIV>
FORTRAN:	</H4>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-49035"></A>      program read_raster_image</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53684"></A>      implicit none</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53685"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53686"></A>C     Parameter declaration</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53687"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53688"></A>      character*19 FILE_NAME</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53689"></A>      integer      X_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53690"></A>      integer      Y_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53691"></A>      integer      N_COMPS</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53692"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53693"></A>      parameter (FILE_NAME  = ’General_RImages.hdf’,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53694"></A>     +           X_LENGTH   = 10,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53695"></A>     +           Y_LENGTH   = 5,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53696"></A>     +           N_COMPS    = 2)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53697"></A>      integer PART_COLS, PART_ROWS, SKIP_COLS, SKIP_ROWS</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53698"></A>      integer COLS_PART_START, ROWS_PART_START</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53699"></A>      integer COLS_SKIP_START, ROWS_SKIP_START</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53700"></A>      integer N_STRIDES</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53701"></A>      parameter (PART_COLS = 3, PART_ROWS = 2,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53702"></A>     +           SKIP_COLS = 3, SKIP_ROWS = 5,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53703"></A>     +           COLS_PART_START = 1, ROWS_PART_START = 3,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53704"></A>     +           COLS_SKIP_START = 0, ROWS_SKIP_START = 1,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53705"></A>     +           N_STRIDES = 2)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53706"></A>      integer DFACC_READ</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53707"></A>      parameter (DFACC_READ = 1)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53708"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53709"></A>C     Function declaration</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53710"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53711"></A>      integer hopen, hclose</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53712"></A>      integer mgstart, mgselct, mgrdimg, mgendac, mgend </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53713"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53714"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53715"></A>C**** Variable declaration *******************************************</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53716"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53717"></A>      integer status</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53718"></A>      integer file_id</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53719"></A>      integer gr_id, ri_id</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53720"></A>      integer start(2), stride(2), edges(2)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53721"></A>      integer i, j</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53722"></A>      integer*2  entire_image(N_COMPS, X_LENGTH, Y_LENGTH) </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53723"></A>      integer*2  partial_image(N_COMPS, PART_ROWS, PART_COLS) </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53724"></A>      integer*2  skipped_image(N_COMPS, SKIP_ROWS, SKIP_COLS) </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53725"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53726"></A>C**** End of variable declaration ************************************</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53727"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53728"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53729"></A>C     Open the HDF file for reading.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53730"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53731"></A>      file_id = hopen(FILE_NAME, DFACC_READ, 0)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53732"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53733"></A>C     Initialize the GR interface.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53734"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53735"></A>      gr_id = mgstart(file_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53736"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53737"></A>C     Select the first raster image in the file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53738"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53739"></A>      ri_id = mgselct(gr_id, 0)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53740"></A>C     </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53741"></A>C     Define the size of the data to be read, i.e., start from the origin</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53742"></A>C     and go as long as the length of each dimension.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53743"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53744"></A>      start(1) = 0</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53745"></A>      start(2) = 0</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53746"></A>      edges(1) = X_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53747"></A>      edges(2) = Y_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53748"></A>      stride(1) = 1</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53749"></A>      stride(2) = 1</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53750"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53751"></A>C     Read the data from the raster image array. </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53752"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53753"></A>      status = mgrdimg(ri_id, start, stride, edges, entire_image)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53754"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53755"></A>C     Display only the first component of the image since the two components</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53756"></A>C     have the same data in this example.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53757"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53758"></A>      write(*,*) ’First component of the entire image’</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53759"></A>      write(*,*)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53760"></A>      do 10 i = 1, X_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53761"></A>         write(*,1000) (entire_image(1,i,j), j = 1, Y_LENGTH)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53762"></A>10    continue</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53763"></A>      write(*,*)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53764"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53765"></A>C     Define the size of the data to be read.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53766"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53767"></A>      start(1) = ROWS_PART_START</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53768"></A>      start(2) = COLS_PART_START </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53769"></A>      edges(1) = PART_ROWS </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53770"></A>      edges(2) = PART_COLS </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53771"></A>      stride(1) = 1</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53772"></A>      stride(2) = 1</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53773"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53774"></A>C     Read a subset of the raster image array. </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53775"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53776"></A>      status = mgrdimg(ri_id, start, stride, edges, partial_image)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53777"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53778"></A>C     Display only the first component of the read sample. </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53779"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53780"></A>      write(*,*)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53781"></A>     +  ’Two rows and three columns at 4th row and 2nd column’,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53782"></A>     +  ’ of the first component’</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53783"></A>      write(*,*)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53784"></A>      do 20 i = 1, PART_ROWS</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53785"></A>         write(*,1000) (partial_image(1,i,j), j = 1, PART_COLS)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53786"></A>20    continue</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53787"></A>      write(*,*)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53788"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53789"></A>C     Define the size and the pattern to read the data.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53790"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53791"></A>      start(1) = ROWS_SKIP_START</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53792"></A>      start(2) = COLS_SKIP_START </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53793"></A>      edges(1) = SKIP_ROWS </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53794"></A>      edges(2) = SKIP_COLS </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53795"></A>      stride(1) = N_STRIDES </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53796"></A>      stride(2) = N_STRIDES </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53797"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53798"></A>C     Read all the odd rows and even columns of the image.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53799"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53800"></A>      status = mgrdimg(ri_id, start, stride, edges, skipped_image)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53801"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53802"></A>C     Display only the first component of the read sample. </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53803"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53804"></A>      write(*,*) ’All even rows and odd columns of the first component’</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53805"></A>      write(*,*)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53806"></A>      do 30 i = 1, SKIP_ROWS</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53807"></A>         write(*,1000) (skipped_image(1,i,j), j = 1, SKIP_COLS)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53808"></A>30    continue</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53809"></A>      write(*,*)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53810"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53811"></A>C     Terminate access to the raster image and to the GR interface, </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53812"></A>C     and close the HDF file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53813"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53814"></A>      status = mgendac(ri_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53815"></A>      status = mgend(gr_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53816"></A>      status = hclose(file_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53817"></A>1000  format(1x, 5(I4))</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53818"></A>      end</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53819"></A>&nbsp;</P>
<DIV>
<H5 CLASS="Heading2">
<A NAME="50593878_pgfId-10746"></A>	8.8	Difference between the SD and GR Interfaces<DIV>
<IMG SRC="UG_html-50.gif" ALT="">
</DIV>
</H5>
<P CLASS="Body">
<A NAME="50593878_pgfId-66559"></A>There is a difference between the SD and GR interfaces that becomes important in applications or tools that must manipulate both images and two-dimensional SDs.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-66579"></A>The SD and GR interfaces differ in the correspondence between the dimension order in parameter arrays such as <EM CLASS="VarName">
start</EM>
, <EM CLASS="VarName">
stride</EM>
, <EM CLASS="VarName">
edge</EM>
, and <EM CLASS="VarName">
dimsizes</EM>
 and the dimension order in the data array. See the <EM CLASS="FunctionName">
SDreaddata </EM>
and<EM CLASS="FunctionName">
 GRreadimage </EM>
reference manual pages for discussions of the SD and GR approaches, respectively.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-66564"></A>When writing applications or tools to manipulate both images and two-dimensional SDs, this crucial difference between the interfaces must be taken into account.  While the underlying data is stored in row-major order in both cases, the API parameters are not expressed in the same way.  Consider the example of an SD data set and a GR image that are stored as identically-shaped arrays of X columns by Y rows and accessed via the <EM CLASS="FunctionName">
SDreaddata</EM>
 and <EM CLASS="FunctionName">
GRreadimage</EM>
 functions, respectively.  Both functions take the parameters <EM CLASS="VarName">
start</EM>
, <EM CLASS="VarName">
stride</EM>
, and <EM CLASS="VarName">
edge</EM>
.</P>
<UL>
<LI CLASS="Bullet">
<A NAME="50593878_pgfId-66569"></A>For <EM CLASS="FunctionName">
SDreaddata</EM>
, those parameters are expressed in (<EM CLASS="VarName">
y</EM>
,<EM CLASS="VarName">
x</EM>
) or [<EM CLASS="VarName">
row</EM>
,<EM CLASS="VarName">
column</EM>
] order.  For example, <EM CLASS="Code">
start[0]</EM>
 is the starting point in the Y dimension and <EM CLASS="Code">
start[1]</EM>
 is the starting point in the X dimension.  The same ordering holds true for all SD data set manipulation functions.</LI>
<LI CLASS="Bullet">
<A NAME="50593878_pgfId-66574"></A>For <EM CLASS="FunctionName">
GRreadimage</EM>
, those parameters are expressed in (<EM CLASS="VarName">
x</EM>
,<EM CLASS="VarName">
y</EM>
) or [<EM CLASS="VarName">
column</EM>
,<EM CLASS="VarName">
row</EM>
] order.  For example, <EM CLASS="Code">
start[0]</EM>
 is the starting point in the X dimension and <EM CLASS="Code">
start[1]</EM>
 is the starting point in the Y dimension.  The same ordering holds true for all GR functions manipulating image data.</LI>
</UL>
</DIV>
<DIV>
<H5 CLASS="Heading2">
<A NAME="50593878_pgfId-66558"></A>	8.9	Obtaining Information about Files and Raster Images<DIV>
<IMG SRC="UG_html-50.gif" ALT="">
</DIV>
</H5>
<P CLASS="Body">
<A NAME="50593878_pgfId-10747"></A>The routines covered in this section provide methods for obtaining information about all of the images in a file, for identifying images that meet certain criteria, and for obtaining information about specific raster images.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-10748"></A><EM CLASS="FunctionName">
GRfileinfo</EM>
<A NAME="50593878_marker-22523"></A> retrieves the number of images and file attributes in a file. <EM CLASS="FunctionName">
GRgetiminfo</EM>
<A NAME="50593878_marker-37467"></A> provides information about individual images. To retrieve information about all images in a file, a calling program can use <EM CLASS="FunctionName">
GRfileinfo</EM>
 to determine the number of images, followed by repeated calls to <EM CLASS="FunctionName">
GRgetiminfo</EM>
 to obtain information about each image.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-37493"></A><EM CLASS="FunctionName">
GRnametoindex</EM>
 or <EM CLASS="FunctionName">
GRreftoindex</EM>
 can be used to obtain the index of a raster image in a file knowing its name or reference number, respectively. Refer to <EM CLASS="Body">
<A HREF="UG_html-8.htm#50593878_36435" CLASS="XRef">Required GR Data Set Components</A></EM>
 for a description of the raster image index and reference number. <EM CLASS="FunctionName">
GRidtoref</EM>
 is used when the reference number of an image is required by another routine and the raster image identifier is available.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-37497"></A>These routines are described individually in the following subsections.</P>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-10756"></A>	8.9.1	<A NAME="50593878_18290"></A>Obtainin<A NAME="50593878_marker-22522"></A>g Information about the Contents of a File: GRfileinfo</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-61007"></A><EM CLASS="FunctionName">
GRfileinfo</EM>
 retrieves the number of raster images and the number of file attributes contained in a file. This information is often useful in index validation, sequential searches, or memory allocation. The syntax of <EM CLASS="FunctionName">
GRfileinfo</EM>
 is as follows:</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-61008"></A><EM CLASS="syntaxLang">
C:</EM>
		status = GRfileinfo(gr_id, &amp;n_images, &amp;n_file_attrs);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-61009"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	status = mgfinfo(gr_id, n_images, n_file_attrs)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-10765"></A>The number of images in the file and the total number of file attributes will be stored in the arguments <EM CLASS="VarName">
n_images</EM>
 and <EM CLASS="VarName">
n_file_attrs</EM>
, respectively. </P>
<P CLASS="Body">
<A NAME="50593878_pgfId-54861"></A><EM CLASS="FunctionName">
GRfileinfo</EM>
 returns <EM CLASS="DefName">
SUCCEED</EM>
 (or <EM CLASS="DefName">
0</EM>
) if successful or <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
) otherwise.  The parameters for <EM CLASS="FunctionName">
GRfileinfo</EM>
 are further described in <A HREF="UG_html-8.htm#50593878_22684" CLASS="XRef">GRfileinfo and GRgetiminfo Parameter Lists</A>.</P>
</DIV>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-19016"></A>	8.9.2	<A NAME="50593878_21293"></A>Ob<A NAME="50593878_marker-22524"></A>taining Information about an Image: GRgetiminfo</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-37572"></A>It is impossible to allocate the proper amount of memory to buffer the image data when the number of components, dimension sizes, and/or data type of the image are unknown. The routine <EM CLASS="FunctionName">
GRgetiminfo</EM>
<A NAME="50593878_marker-37587"></A> retrieves this required information. To access information about an image, the calling program must contain the following:</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-37597"></A><EM CLASS="syntaxLang">
C:</EM>
		status = GRgetiminfo(ri_id, name, &amp;n_comps, &amp;data_type, &amp;interlace_mode, dim_sizes, &amp;n_attrs);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-37601"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	status = mggiinf(ri_id, name, n_comps, data_type, interlace_mode, dim_sizes, n_attrs)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-43686"></A><EM CLASS="FunctionName">
GRgetiminfo</EM>
 takes a raster image identifier as input, and returns the name, number of components, data type, interlace mode, dimension size, and number of attributes for the corresponding image in the arguments <EM CLASS="VarName">
name</EM>
, <EM CLASS="VarName">
n_comps</EM>
, <EM CLASS="VarName">
data_type</EM>
, <EM CLASS="VarName">
interlace_mode</EM>
, <EM CLASS="VarName">
dim_sizes</EM>
, and <EM CLASS="VarName">
n_attrs</EM>
 respectively. The number of components of an image array element corresponds to the order of a vdata field, therefore this implementation of image components in the GR interface is flexible enough to accommodate any representation of pixel data. The calling program determines this representation; the GR interface recognizes only the raw byte configuration of the data. The attribute count will only reflect the number of attributes assigned to the image array; file attributes are not included.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-37612"></A><EM CLASS="FunctionName">
GRgetiminfo</EM>
 returns either <EM CLASS="DefName">
SUCCEED</EM>
 (or <EM CLASS="DefName">
0</EM>
) or <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
). The parameters of this routine are further defined in <A HREF="UG_html-8.htm#50593878_22684" CLASS="XRef">Table 8G</A>.</P>
<DIV>
<H6 CLASS="Table">
<A NAME="50593878_pgfId-10901"></A><DIV>
<IMG SRC="UG_html-51.gif" ALT="">
</DIV>
<A NAME="50593878_22684"></A>GRf<A NAME="50593878_marker-22526"></A>ileinfo and GRg<A NAME="50593878_marker-22527"></A>etiminfo Parameter Lists</H6>
<TABLE>
<TR>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-16925"></A>Routine Name</P>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-29931"></A>[Return Type]</H6>
<P CLASS="TableHead">
<A NAME="50593878_pgfId-16926"></A>(FORTRAN-77)</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-16928"></A>Parameter</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-16932"></A>Parameter Type</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-16934"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-16940"></A>C</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-16942"></A>FORTRAN-77</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="3" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-16946"></A>GRfileinfo</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-29932"></A>[intn]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-16947"></A>(mgfinfo)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16949"></A>gr_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16951"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16953"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-16955"></A>GR interface identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16959"></A>n_images</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16961"></A>int32 *</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16963"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-16965"></A>Number of raster images in the file</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16969"></A>n_file_attrs</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16971"></A>int32 *</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16973"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-16975"></A>Number of global attributes in the file</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="7" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-16977"></A>GRgetiminfo</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-29933"></A>[intn]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-16978"></A>(mggiinf)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16980"></A>ri_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16982"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16984"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-16986"></A>Raster image identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16990"></A>name</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16992"></A>char *</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16994"></A>character*(*)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-16996"></A>Name of the raster image</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-17000"></A>n_comps</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-17002"></A>int32 *</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-17004"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-17006"></A>Number of pixel components in the pixel</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-17010"></A>data_type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-17012"></A>int32 *</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-17014"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-17016"></A>Pixel data type</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-17020"></A>interlace_mode</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-17022"></A>int32 *</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-17024"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-17026"></A>Interlace mode of the data in the raster image</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-17030"></A>dim_sizes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-17032"></A>int32 [2]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-17034"></A>integer (2)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-17036"></A>Array containing the size of each dimension in the raster image</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-17040"></A>n_attrs</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-17042"></A>int32 *</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-17044"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-17046"></A>Number of raster image attributes</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-31848"></A>	8.9.3	<A NAME="50593878_10010"></A>Obtain<A NAME="50593878_marker-31847"></A>ing the Reference Number of a Raster Image from Its Identifier: GRidtoref</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-32068"></A><EM CLASS="FunctionName">
GRidtoref</EM>
<A NAME="50593878_marker-31867"></A> returns either the reference number of the raster image identified by the parameter <EM CLASS="VarName">
ri_id</EM>
, or <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
) upon unsuccessful completion. The syntax of <EM CLASS="FunctionName">
GRidtoref</EM>
 is as follows:</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-31873"></A><EM CLASS="syntaxLang">
C:</EM>
		ref = GRidtoref(ri_id);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-37718"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	ref = mgid2rf(ri_id)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-37871"></A>This routine is further defined in <A HREF="UG_html-8.htm#50593878_27712" CLASS="XRef">GRidtoref, GRreftoindex, GRnametoindex, and GRgetcompinfo Parameter Lists</A>.</P>
</DIV>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-37873"></A>	8.9.4	Obtaining the Index of a Raster<A NAME="50593878_28236"></A> Image from Its Reference Number: GRreftoindex</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-37844"></A><EM CLASS="FunctionName">
GRreftoindex</EM>
<A NAME="50593878_marker-31959"></A> returns either the index of the raster image specified by its reference number, <EM CLASS="VarName">
ref</EM>
, or <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
) upon unsuccessful completion. The syntax of <EM CLASS="FunctionName">
GRreftoindex</EM>
 is as follows:</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-31973"></A><EM CLASS="syntaxLang">
C:</EM>
		ri_index = GRreftoindex(gr_id, ref);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-31974"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	ri_index = mgr2idx(gr_id, ref)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-31731"></A>This routine is further defined in <A HREF="UG_html-8.htm#50593878_27712" CLASS="XRef">Table 8H</A>.</P>
</DIV>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-37853"></A>	8.9.5	<A NAME="50593878_17067"></A>Obtaining the Index of a Raster Image from Its Name: GRnametoindex</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-37664"></A><EM CLASS="FunctionName">
GRnametoindex </EM>
returns the index of the raster image specified by its name or <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
) upon unsuccessful completion. The syntax of <EM CLASS="FunctionName">
GRnametoindex</EM>
 is as follows:</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-31732"></A><EM CLASS="syntaxLang">
C:</EM>
		ri_index = GRnametoindex(gr_id, name);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-31734"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	ri_index = mgr2idx(gr_id, name)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-32079"></A>This routine is further defined in <A HREF="UG_html-8.htm#50593878_27712" CLASS="XRef">Table 8H</A>.</P>
</DIV>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-66280"></A>	8.9.6	<A NAME="50593878_54086"></A>Obtaining Compression Information for a Raster Image: GRgetcompinfo</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-66844"></A><EM CLASS="FunctionName">
GRgetcompinfo </EM>
retrieves the type of compression used to store a raster image and, when appropriate, the required compression parameters. <EM CLASS="FunctionName">
 GRgetcompinfo</EM>
 replaces <EM CLASS="FunctionName">
GRgetcompress</EM>
 because this function has flaws, causing failure for some chunked and chunked/compressed data.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-66300"></A><EM CLASS="FunctionName">
GRgetcompinfo </EM>
takes one input parameter, <EM CLASS="VarName">
ri_id</EM>
, a raster image identifier, and two output parameters, <EM CLASS="VarName">
comp_type</EM>
, for the type of compression used when the image was written, and either <EM CLASS="VarName">
c_info</EM>
 (a C struct) or <EM CLASS="VarName">
comp_prm</EM>
 (a FORTRAN-77 array) for the returned compression parameters.  </P>
<P CLASS="Body">
<A NAME="50593878_pgfId-66501"></A>Valid <EM CLASS="VarName">
comp_type</EM>
 values are as follows:</P>
<P CLASS="List10pt">
<A NAME="50593878_pgfId-66507"></A>COMP_CODE_NONE (or 0) for no compression</P>
<P CLASS="List10pt">
<A NAME="50593878_pgfId-66529"></A>COMP_CODE_RLE (or 1) for RLE run-length encoding</P>
<P CLASS="List10pt">
<A NAME="50593878_pgfId-66509"></A>COMP_CODE_SKPHUFF (or 3) for Skipping Huffman compression</P>
<P CLASS="List10pt">
<A NAME="50593878_pgfId-66510"></A>COMP_CODE_DEFLATE (or 4) for GZIP compression</P>
<P CLASS="List10pt">
<A NAME="50593878_pgfId-209795"></A>COMP_CODE_SZIP (or 5) for Szip compression (not for Fortran)</P>
<P CLASS="List10pt">
<A NAME="50593878_pgfId-209812"></A>COMP_CODE_JPEG (or 7) for JPEG compression</P>
<P CLASS="List10pt">
<A NAME="50593878_pgfId-209823"></A>COMP_CODE_IMCOMP (or 12) for IMCOMP compression</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-209814"></A>The <EM CLASS="VarName">
c_info</EM>
 struct is of type<EM CLASS="DefName">
 comp_info</EM>
, contains algorithm-specific information for the library compression routines, and is described in the<EM CLASS="DefName">
 hcomp.h </EM>
header file.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-66542"></A>The <EM CLASS="VarName">
comp_prm</EM>
 parameter is an array of several elements.  </P>
<P CLASS="Body">
<A NAME="50593878_pgfId-76811"></A>For Skipping Huffman compression, <EM CLASS="VarName">
comp_prm(1) </EM>
contains the skip value,<EM CLASS="VarName">
 </EM>
<EM CLASS="Code">
skphuff_skp_size</EM>
.  </P>
<P CLASS="Body">
<A NAME="50593878_pgfId-76810"></A>For GZIP compression, <EM CLASS="VarName">
comp_prm(1) </EM>
contains the deflation value,<EM CLASS="VarName">
 </EM>
<EM CLASS="Code">
deflate_value</EM>
.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-76829"></A>For other compression types,<EM CLASS="VarName">
 comp_prm </EM>
is ignored.  Currently, Szip is not yet supported in Fortran GR interface.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-66399"></A><EM CLASS="FunctionName">
GRgetcompinfo </EM>
returns <EM CLASS="DefName">
SUCCESS</EM>
 (or <EM CLASS="DefName">
0</EM>
) if it is successful or <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
) upon unsuccessful completion. </P>
<P CLASS="Body">
<A NAME="50593878_pgfId-66400"></A>The syntax of <EM CLASS="FunctionName">
GRgetcompinfo</EM>
 is as follows:</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-66284"></A><EM CLASS="syntaxLang">
C:</EM>
		status = GRgetcompinfo(ri_id, comp_type, c_info);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-66285"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	status = mggcompress(ri_id, comp_type, comp_prm)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-66289"></A>This routine is further defined in <A HREF="UG_html-8.htm#50593878_27712" CLASS="XRef">Table 8H</A>.</P>
</DIV>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-125548"></A>	8.9.7	Checking Whether a Raster Image Is To Be Mapped: GR2bmapped</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-125725"></A>This function was originally added to support the HDF4 File Content Project.  The tool, produced from the project, maps the contents of HDF4 files.  Supporting for raster images was limited as requested by the project’s sponsor.  Thus, only certain types of images, which satisfy a set of conditions, are to be mapped.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-125726"></A><EM CLASS="FunctionName">
GR2bmapped </EM>
will set <EM CLASS="VarName">
tobe_mapped</EM>
 to <EM CLASS="DefName">
TRUE</EM>
 if the given raster image, <EM CLASS="VarName">
ri_id</EM>
, satisfies the following conditions:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="50593878_pgfId-125671"></A>being an 8-bit raster image,</LI>
<LI CLASS="Bullet">
<A NAME="50593878_pgfId-125672"></A>having one component,</LI>
<LI CLASS="Bullet">
<A NAME="50593878_pgfId-125673"></A>being non-special or RLE compressed only, i.e., no other compressions or chunking,</LI>
</UL>
<P CLASS="Body">
<A NAME="50593878_pgfId-125699"></A>or <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
), otherwise.  The syntax of <EM CLASS="FunctionName">
GR2bmapped</EM>
 is as follows:</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-125550"></A><EM CLASS="syntaxLang">
C:</EM>
		status = GR2bmapped(ri_id, &amp;tobe_mapped, &amp;name_generated);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-125745"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
		Unavailable</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-125746"></A>Another characteristic of the image to be reported by <EM CLASS="FunctionName">
GR2bmapped</EM>
 is whether the image has name that was generated by the library and, if so, <EM CLASS="VarName">
name_generated</EM>
 will be set to <EM CLASS="DefName">
TRUE</EM>
.  Old images (or images created with pre-GR API) do not have a name and the library would generate a name for it while reading in the file.  The tool from the HDF4 File Content Project needs to make this distinction.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-125747"></A><EM CLASS="FunctionName">
GR2bmapped </EM>
returns <EM CLASS="DefName">
SUCCEED</EM>
 (or <EM CLASS="DefName">
0</EM>
), if successful, or <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
), otherwise.  When failure occurs, <EM CLASS="VarName">
tobe_mapped</EM>
 and <EM CLASS="VarName">
name_generated</EM>
 will be undefined.  This routine is further defined in <A HREF="UG_html-8.htm#50593878_27712" CLASS="XRef">Table 8H</A>.</P>
<DIV>
<H6 CLASS="Table">
<A NAME="50593878_pgfId-11169"></A><DIV>
<IMG SRC="UG_html-51.gif" ALT="">
</DIV>
<A NAME="50593878_27712"></A>GRidtoref, GRreftoi<A NAME="50593878_marker-22531"></A>ndex, GRn<A NAME="50593878_marker-22532"></A>ametoindex, and GRgetcompinfo Parameter Lists</H6>
<TABLE>
<TR>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-125867"></A>Routine Name</P>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-125868"></A>[Return Type]</H6>
<P CLASS="TableHead">
<A NAME="50593878_pgfId-125869"></A>(FORTRAN-77)</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-125871"></A>Parameter</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-125873"></A>Parameter Type</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-125877"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-125883"></A>C</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-125885"></A>FORTRAN-77</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-125889"></A>GRidtoref</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-125890"></A>[uint16]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-125891"></A>(mgid2rf)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125893"></A>ri_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125895"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125897"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-125899"></A>Raster image identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="2" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-125901"></A>GRreftoindex</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-125902"></A>[int32]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-125903"></A>(mgr2idx)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125905"></A>gr_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125907"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125909"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-125911"></A>GR interface identifier </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125915"></A>ref</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125917"></A>uint16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125919"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-125921"></A>Reference number of the raster image</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="2" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-125923"></A>GRnametoindex</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-125924"></A>[int32]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-125925"></A>(mgn2ndx)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125927"></A>gr_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125929"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125931"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-125933"></A>GR interface identifier </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125937"></A>name</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125939"></A>char *</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125941"></A>character *(*)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-125943"></A>Name of the raster image</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="4" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-126020"></A>GRgetcompinfo</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-126021"></A>[intn]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-126022"></A>(mggcompress)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126024"></A>ri_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126026"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126028"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-126030"></A>Raster image identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126034"></A>comp_type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126036"></A>comp_coder_t</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126038"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-126040"></A>Type of compression</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126044"></A>c_info</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126046"></A>comp_info</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126048"></A>N/A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-126050"></A>Pointer to compression information structure</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126054"></A>comp_prm(1)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126056"></A>N/A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126058"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-126060"></A>Compression parameter in array format</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="3" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-125945"></A>GR2bmapped</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-125946"></A>[intn]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-125947"></A>(unavailable)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125949"></A>ri_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125951"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125953"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-125955"></A>Raster image identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125959"></A>tobe_mapped</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125961"></A>intn *</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125963"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-125965"></A>TRUE if the image should be mapped</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125969"></A>name_generated</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125971"></A>intn *</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-125973"></A>N/A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-126078"></A>TRUE if the image's name was generated by the GR API, i.e., not given by applications</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Example">
<A NAME="50593878_pgfId-11170"></A><DIV>
<IMG SRC="UG_html-51.gif" ALT="">
</DIV>
Obtaining File and Image Information.</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-49207"></A>This example illustrates the use of the routines <EM CLASS="FunctionName">
GRfileinfo/mgfinfo</EM>
 and <EM CLASS="FunctionName">
GRgetiminfo/mggiinf</EM>
 to obtain information such as the number of images and attributes in an HDF file and the characteristics of a raster image in the file.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-49212"></A>In this example, the program gets the number of images in the file using the routine <EM CLASS="FunctionName">
GRfileinfo/mgfinfo</EM>
. For each image, the program then obtains and displays its name, number of components, data type, interlace mode, dimension sizes, and number of attributes using the routine <EM CLASS="FunctionName">
GRgetiminfo/mggiinf</EM>
.</P>
</DIV>
</DIV>
</DIV>
</DIV>
<DIV>
<H4 CLASS="Code-C-Title">
<A NAME="50593878_pgfId-11172"></A><DIV>
<IMG SRC="UG_html-53.gif" ALT="">
</DIV>
C:		</H4>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-49348"></A>#include &quot;hdf.h&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53823"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53824"></A>#define  FILE_NAME    &quot;General_RImages.hdf&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53825"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53826"></A>main( ) </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53827"></A>{</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53828"></A>   /************************* Variable declaration **************************/</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53829"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53830"></A>   intn  status;            /* status for functions returning an intn */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53831"></A>   int32 file_id, gr_id, ri_id,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53832"></A>         n_rimages,         /* number of raster images in the file */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53833"></A>         n_file_attrs,      /* number of file attributes */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53834"></A>         ri_index,          /* index of a image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53835"></A>         dim_sizes[2],      /* dimensions of an image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53836"></A>         n_comps,           /* number of components an image contains */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53837"></A>         interlace_mode,    /* interlace mode of an image */ </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53838"></A>         data_type,         /* number type of an image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53839"></A>         n_attrs;           /* number of attributes belong to an image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53840"></A>   char  name[MAX_GR_NAME], /* name of an image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53841"></A>        *type_string,       /* mapped text of a number type */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53842"></A>        *interlace_string;  /* mapped text of an interlace mode */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53843"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53844"></A>   /********************** End of variable declaration **********************/</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53845"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53846"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53847"></A>   * Open the file for reading.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53848"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53849"></A>   file_id = Hopen (FILE_NAME, DFACC_READ, 0);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53850"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53851"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53852"></A>   * Initialize the GR interface.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53853"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53854"></A>   gr_id = GRstart (file_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53855"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53856"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53857"></A>   * Determine the contents of the file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53858"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53859"></A>   status = GRfileinfo (gr_id, &amp;n_rimages, &amp;n_file_attrs);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53860"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53861"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53862"></A>   * For each image in the file, get and display the image information.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53863"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53864"></A>   printf (&quot;RI#    Name       Components  Type         Interlace     \</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53865"></A>   Dimensions   Attributes\n\n&quot;);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53866"></A>   for (ri_index = 0; ri_index &lt; n_rimages; ri_index++)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53867"></A>   {</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53868"></A>      ri_id = GRselect (gr_id, ri_index);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53869"></A>      status = GRgetiminfo (ri_id, name, &amp;n_comps, &amp;data_type, </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53870"></A>                          &amp;interlace_mode, dim_sizes, &amp;n_attrs);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53871"></A>      /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53872"></A>      * Map the number type and interlace mode into text strings for output </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53873"></A>      * readability.  Note that, in this example, only two possible types </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53874"></A>      * are considered because of the simplicity of the example.  For real </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53875"></A>      * problems, all possible types should be checked and, if reading the</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53876"></A>      * data is desired, the size of the type must be determined based on the</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53877"></A>      * machine where the program resides.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53878"></A>      */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53879"></A>      if (data_type == DFNT_CHAR8)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53880"></A>         type_string = &quot;Char8&quot;;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53881"></A>      else if (data_type == DFNT_INT16)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53882"></A>         type_string = &quot;Int16&quot;;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53883"></A>      else</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53884"></A>         type_string = &quot;Unknown&quot;;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53885"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53886"></A>      switch (interlace_mode)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53887"></A>      {</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53888"></A>         case MFGR_INTERLACE_PIXEL:</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53889"></A>            interlace_string = &quot;MFGR_INTERLACE_PIXEL&quot;;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53890"></A>            break;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53891"></A>         case MFGR_INTERLACE_LINE:</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53892"></A>            interlace_string = &quot;MFGR_INTERLACE_LINE&quot;;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53893"></A>            break;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53894"></A>         case MFGR_INTERLACE_COMPONENT:</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53895"></A>            interlace_string = &quot;MFGR_INTERLACE_COMPONENT&quot;;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53896"></A>            break;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53897"></A>         default:</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53898"></A>            interlace_string = &quot;Unknown&quot;;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53899"></A>            break;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53900"></A>      } /* switch */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53901"></A> &nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53902"></A>      /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53903"></A>      * Display the image information for the current raster image.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53904"></A>      */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53905"></A>          printf (&quot;%d  %s       %d      %s   %s     %2d,%2d         %d\n&quot;, </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53906"></A>                 ri_index, name, n_comps, type_string, interlace_string,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53907"></A>                 dim_sizes[0], dim_sizes[1], n_attrs);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53908"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53909"></A>      /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53910"></A>      * Terminate access to the current raster image.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53911"></A>      */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53912"></A>      status = GRendaccess (ri_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53913"></A>   }</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53914"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53915"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53916"></A>   * Terminate access to the GR interface and close the HDF file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53917"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53918"></A>   status = GRend (gr_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53919"></A>   status = Hclose (file_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53920"></A>}</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53921"></A>&nbsp;</P>
</DIV>
<DIV>
<H4 CLASS="Code-F-Title">
<A NAME="50593878_pgfId-11204"></A><DIV>
<IMG SRC="UG_html-53.gif" ALT="">
</DIV>
FORTRAN:	</H4>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-49445"></A>      program image_info</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53924"></A>      implicit none</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53925"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53926"></A>C     Parameter declaration</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53927"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53928"></A>      character*19 FILE_NAME</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53929"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53930"></A>      parameter (FILE_NAME = ’General_RImages.hdf’)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53931"></A>      integer DFACC_READ</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53932"></A>      parameter (DFACC_READ = 1)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53933"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53934"></A>C     Function declaration</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53935"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53936"></A>      integer hopen, hclose</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53937"></A>      integer mgstart, mgselct, mgfinfo, mggiinf, mgendac, mgend </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53938"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53939"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53940"></A>C**** Variable declaration *******************************************</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53941"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53942"></A>      integer status</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53943"></A>      integer file_id, gr_id, ri_id</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53944"></A>      integer n_rimages, n_file_attrs, ri_index</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53945"></A>      integer n_comps, interlace_mode, n_attrs, data_type</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53946"></A>      integer dim_sizes(2)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53947"></A>      character*10 type_string</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53948"></A>      character*24 interlace_string</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53949"></A>      character*64 name</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53950"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53951"></A>C**** End of variable declaration ************************************</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53952"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53953"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53954"></A>C     Open the HDF file for reading.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53955"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53956"></A>      file_id = hopen(FILE_NAME, DFACC_READ, 0)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53957"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53958"></A>C     Initialize the GR interface.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53959"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53960"></A>      gr_id = mgstart(file_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53961"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53962"></A>C     Determine the contents of the file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53963"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53964"></A>      status = mgfinfo(gr_id, n_rimages, n_file_attrs)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53965"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53966"></A>C     For each image in the file, get and display image information.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53967"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53968"></A>      do 100 ri_index = 0, n_rimages-1</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53969"></A>         ri_id = mgselct(gr_id, ri_index)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53970"></A>         status = mggiinf(ri_id, name, n_comps, data_type,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53971"></A>     +                    interlace_mode, dim_sizes, n_attrs)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53972"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53973"></A>C     Map the number type and interlace mode into text strings for</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53974"></A>C     output readability.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53975"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53976"></A>      if(data_type .eq. 4) then</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53977"></A>         type_string = ’DFNT_CHAR8’</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53978"></A>      else if(data_type .eq. 22) then</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53979"></A>         type_string = ’DFNT_INT16’</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53980"></A>      else</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53981"></A>         type_string = ’Unknown’</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53982"></A>      endif</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53983"></A>      if (interlace_mode .eq. 0) then</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53984"></A>          interlace_string = ’MFGR_INTERLACE_PIXEL’</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53985"></A>      else if(interlace_mode .eq. 1) then</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53986"></A>          interlace_string = ’MFGR_INTERLACE_LINE’</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53987"></A>      else if(interlace_mode .eq. 2) then</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53988"></A>          interlace_string = ’MFGR_INTERLACE_COMPONENT’</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53989"></A>      else</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53990"></A>         interlace_string = ’Unknown’</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53991"></A>      endif</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53992"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53993"></A>C     Display the image information for the current image.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53994"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53995"></A>      write(*,*) ’Image index: ’, ri_index</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53996"></A>      write(*,*) ’Image name: ’, name </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53997"></A>      write(*,*) ’Number of components: ’, n_comps</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53998"></A>      write(*,*) ’Number type: ’, type_string </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-53999"></A>      write(*,*) ’Interlace mode: ’, interlace_string</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54000"></A>      write(*,*) ’Dimnesions: ’, dim_sizes(1), dim_sizes(2)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54001"></A>      write(*,*) ’Number of image attributes: ’, n_attrs</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54002"></A>      write(*,*) </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54003"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54004"></A>C     Terminate access to the current raster image.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54005"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54006"></A>      status = mgendac(ri_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54007"></A>100   continue</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54008"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54009"></A>C     Terminate access to the GR interface and close the HDF file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54010"></A>      status = mgend(gr_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54011"></A>      status = hclose(file_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54012"></A>      end</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-55751"></A>&nbsp;</P>
<DIV>
<H5 CLASS="Heading2">
<A NAME="50593878_pgfId-55754"></A>	8.10	<A NAME="50593878_26405"></A><A NAME="50593878_marker-55753"></A>GR Data Set Attributes<DIV>
<IMG SRC="UG_html-50.gif" ALT="">
</DIV>
</H5>
<P CLASS="Body">
<A NAME="50593878_pgfId-55755"></A>The GR interface provides tools that attach attributes to particular images. This capability is similar to, though more limited than, attribute function capabilities of the SD interface. The concepts of user-defined and predefined attributes are explained in <A HREF="UG_html-3.htm#50593873_13938" CLASS="XRef">Scientific Data Sets (SD API)</A>. The GR implementation of attributes is similar to the SD implementation. Attributes are not written out to a file until access to the object the attribute is attached to is terminated.</P>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-17163"></A>	8.10.1	<A NAME="50593878_55039"></A>Predefine<A NAME="50593878_marker-22626"></A>d GR Attributes</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-17169"></A>The GR API library has only one predefined attribute: <EM CLASS="DefName">
FILL_ATTR</EM>
<A NAME="50593878_marker-22629"></A>. This attribute defines a fill pixel, which is analogous to a fill value in the SD interface. It represents the default value that is written to each element of an image array not explicitly written to by the calling program, i.e., when only a portion of the entire image array is filled with data. This value must of the same data type as the rest of the initialized image data. The routi<A NAME="50593878_marker-22628"></A>ne used to set the fill value, <EM CLASS="FunctionName">
GRsetattr</EM>
, is explained in the next section.</P>
</DIV>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-11603"></A>	8.10.2	<A NAME="50593878_33193"></A>Setting User-d<A NAME="50593878_marker-22627"></A>efined Attributes: GRsetattr</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-11604"></A><EM CLASS="FunctionName">
GRsetattr</EM>
 creates or modifies an attribute for either a file or a raster image. If the attribute with the specified name does not exist, <EM CLASS="FunctionName">
GRsetattr</EM>
 creates a new one. If the named attribute already exists, <EM CLASS="FunctionName">
GRsetattr</EM>
 resets all the values that are different from those provided in its argument list. The syntax of <EM CLASS="FunctionName">
GRsetattr</EM>
 is as follows:</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-11614"></A><EM CLASS="syntaxLang">
C:	</EM>
	status = GRsetattr(obj_id, attr_name, data_type, n_values, attr_value);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-11616"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	status = mgsnatt(obj_id, attr_name, data_type, n_values, attr_value)</P>
<P CLASS="syntax-or-bot">
<A NAME="50593878_pgfId-38013"></A>	<EM CLASS="syntaxLang">
OR</EM>
	status = mgscatt(obj_id, attr_name, data_type, n_values, attr_value)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-38014"></A>The first argument, <EM CLASS="VarName">
obj_id</EM>
, can either be the GR interface identifier or raster image identifier. The argument <EM CLASS="VarName">
attr_name</EM>
 contains the name of the attribute and can be no more than <EM CLASS="DefName">
H4_MAX_GR_NAME</EM>
 (or<EM CLASS="DefName">
 256</EM>
) characters in length. Passing the name of an existing attribute will overwrite the value portion of that attribute. </P>
<P CLASS="Body">
<A NAME="50593878_pgfId-11622"></A>The arguments <EM CLASS="VarName">
data_type</EM>
, <EM CLASS="VarName">
n_values</EM>
, and <EM CLASS="VarName">
attr_value</EM>
 describe the right side of the <EM CLASS="VarName">
label=value</EM>
 equation. The <EM CLASS="VarName">
attr_value</EM>
 argument contains one or more values of the same data type. The <EM CLASS="VarName">
data_type</EM>
 argument describes the data type for all values in the attribute and <EM CLASS="VarName">
n_values</EM>
 contains the total number of values in the attribute. </P>
<P CLASS="Body">
<A NAME="50593878_pgfId-22905"></A>Note that the FORTRAN-77 version of <EM CLASS="FunctionName">
GRsetattr</EM>
 has two routines; <EM CLASS="FunctionName">
mgsnatt</EM>
 writes numeric attribute data and <EM CLASS="FunctionName">
mgscatt</EM>
 writes character attribute data.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-33558"></A><EM CLASS="FunctionName">
GRsetattr</EM>
 returns either <EM CLASS="DefName">
SUCCEED</EM>
 (or <EM CLASS="DefName">
0</EM>
) or <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
). The parameters for <EM CLASS="FunctionName">
GRsetattr</EM>
 are further described in <A HREF="UG_html-8.htm#50593878_15192" CLASS="XRef">GRsetattr, GRfindattr, GRattrinfo, and GRgetattr Parameter Lists</A>.</P>
<DIV>
<H6 CLASS="Example">
<A NAME="50593878_pgfId-11626"></A><DIV>
<IMG SRC="UG_html-51.gif" ALT="">
</DIV>
Operations on File and Raster Image Attributes.</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-49458"></A>This example illustrates the use of the routines <EM CLASS="FunctionName">
GRsetattr/mgsnatt/mgscatt</EM>
 to assign attributes to an HDF file and to an image.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-49461"></A>In this example, the program sets two attributes to the existing file &quot;General_RImages.hdf&quot; and two attributes to the image named &quot;Image Array 2&quot;. The file is created by the program in Example 1 and the image is created by the program in Example 2.  The values of the second attribute of the image are of type <EM CLASS="VarName">
int16</EM>
 and the values of the other three attributes are of type <EM CLASS="VarName">
char8</EM>
.</P>
</DIV>
</DIV>
</DIV>
</DIV>
<DIV>
<H4 CLASS="Code-C-Title">
<A NAME="50593878_pgfId-25200"></A><DIV>
<IMG SRC="UG_html-53.gif" ALT="">
</DIV>
C:		</H4>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-49571"></A>#include &quot;hdf.h&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54017"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54018"></A>#define  FILE_NAME          &quot;General_RImages.hdf&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54019"></A>#define  IMAGE_NAME         &quot;Image Array 2&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54020"></A>#define  F_ATT1_NAME        &quot;File Attribute 1&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54021"></A>#define  F_ATT2_NAME        &quot;File Attribute 2&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54022"></A>#define  RI_ATT1_NAME       &quot;Image Attribute 1&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54023"></A>#define  RI_ATT2_NAME       &quot;Image Attribute 2&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54024"></A>#define  F_ATT1_VAL         &quot;Contents of First FILE Attribute&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54025"></A>#define  F_ATT2_VAL         &quot;Contents of Second FILE Attribute&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54026"></A>#define  F_ATT1_N_VALUES    32</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54027"></A>#define  F_ATT2_N_VALUES    33</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54028"></A>#define  RI_ATT1_VAL        &quot;Contents of IMAGE’s First Attribute&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54029"></A>#define  RI_ATT1_N_VALUES   35</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54030"></A>#define  RI_ATT2_N_VALUES   6</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54031"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54032"></A>main( ) </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54033"></A>{</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54034"></A>   /************************* Variable declaration **************************/</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54035"></A>   </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54036"></A>   intn  status;         /* status for functions returning an intn */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54037"></A>   int32 gr_id, ri_id, file_id,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54038"></A>         ri_index;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54039"></A>   int16 ri_attr_2[RI_ATT2_N_VALUES] = {1, 2, 3, 4, 5, 6};</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54040"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54041"></A>   /********************** End of variable declaration **********************/</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54042"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54043"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54044"></A>   * Open the HDF file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54045"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54046"></A>   file_id = Hopen (FILE_NAME, DFACC_WRITE, 0);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54047"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54048"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54049"></A>   * Initialize the GR interface.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54050"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54051"></A>   gr_id = GRstart (file_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54052"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54053"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54054"></A>   * Set two file attributes to the file with names, data types, numbers of </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54055"></A>   * values, and values of the attributes specified.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54056"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54057"></A>   status = GRsetattr (gr_id, F_ATT1_NAME, DFNT_CHAR8, F_ATT1_N_VALUES, </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54058"></A>                       (VOIDP)F_ATT1_VAL); </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54059"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54060"></A>   status = GRsetattr (gr_id, F_ATT2_NAME, DFNT_CHAR8, F_ATT2_N_VALUES, </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54061"></A>                       (VOIDP)F_ATT2_VAL);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54062"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54063"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54064"></A>   * Obtain the index of the image named IMAGE_NAME.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54065"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54066"></A>   ri_index = GRnametoindex (gr_id, IMAGE_NAME);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54067"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54068"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54069"></A>   * Obtain the identifier of this image.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54070"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54071"></A>   ri_id = GRselect (gr_id, ri_index);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54072"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54073"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54074"></A>   * Set two attributes to the image with names, data types, numbers of </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54075"></A>   * values, and values of the attributes specified.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54076"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54077"></A>   status = GRsetattr (ri_id, RI_ATT1_NAME, DFNT_CHAR8, RI_ATT1_N_VALUES, </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54078"></A>                       (VOIDP)RI_ATT1_VAL);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54079"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54080"></A>   status = GRsetattr (ri_id, RI_ATT2_NAME, DFNT_INT16, RI_ATT2_N_VALUES, </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54081"></A>                       (VOIDP)ri_attr_2);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54082"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54083"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54084"></A>   * Terminate access to the image and to the GR interface, and close the</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54085"></A>   * HDF file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54086"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54087"></A>   status = GRendaccess (ri_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54088"></A>   status = GRend (gr_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54089"></A>   status = Hclose (file_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54090"></A>}</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54091"></A>&nbsp;</P>
</DIV>
<DIV>
<H4 CLASS="Code-F-Title">
<A NAME="50593878_pgfId-11658"></A><DIV>
<IMG SRC="UG_html-53.gif" ALT="">
</DIV>
FORTRAN:	</H4>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-49674"></A>      program  set_attribute</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54093"></A>      implicit none</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54094"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54095"></A>C     Parameter declaration</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54096"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54097"></A>      character*19 FILE_NAME</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54098"></A>      character*13 IMAGE_NAME</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54099"></A>      character*16 F_ATT1_NAME</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54100"></A>      character*16 F_ATT2_NAME</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54101"></A>      character*17 RI_ATT1_NAME</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54102"></A>      character*17 RI_ATT2_NAME</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54103"></A>      character*32 F_ATT1_VAL</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54104"></A>      character*33 F_ATT2_VAL</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54105"></A>      integer      F_ATT1_N_VALUES</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54106"></A>      integer      F_ATT2_N_VALUES</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54107"></A>      character*35 RI_ATT1_VAL</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54108"></A>      integer      RI_ATT1_N_VALUES</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54109"></A>      integer      RI_ATT2_N_VALUES</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54110"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54111"></A>      parameter (FILE_NAME    = ’General_RImages.hdf’,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54112"></A>     +           IMAGE_NAME   = ’Image Array 2’,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54113"></A>     +           F_ATT1_NAME  = ’File Attribute 1’,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54114"></A>     +           F_ATT2_NAME  = ’File Attribute 2’,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54115"></A>     +           RI_ATT1_NAME = ’Image Attribute 1’,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54116"></A>     +           RI_ATT2_NAME = ’Image Attribute 2’,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54117"></A>     +           F_ATT1_VAL   = ’Contents of First FILE Attribute’,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54118"></A>     +           F_ATT2_VAL   = ’Contents of Second FILE Attribute’,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54119"></A>     +           F_ATT1_N_VALUES = 32,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54120"></A>     +           F_ATT2_N_VALUES = 33,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54121"></A>     +           RI_ATT1_VAL = ’Contents of IMAGE’’s First Attribute’,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54122"></A>     +           RI_ATT1_N_VALUES = 35,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54123"></A>     +           RI_ATT2_N_VALUES = 6)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54124"></A>      integer DFACC_WRITE, DFNT_INT16, DFNT_CHAR8</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54125"></A>      parameter (DFACC_WRITE  = 2,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54126"></A>     +           DFNT_CHAR8   = 4,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54127"></A>     +           DFNT_INT16   = 22)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54128"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54129"></A>C     Function declaration</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54130"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54131"></A>      integer hopen, hclose</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54132"></A>      integer mgstart, mgscatt, mgsnatt , mgn2ndx,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54133"></A>     +        mgselct, mgendac, mgend </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54134"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54135"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54136"></A>C**** Variable declaration *******************************************</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54137"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54138"></A>      integer   status</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54139"></A>      integer   file_id, gr_id, ri_id, ri_index</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54140"></A>      integer*2 ri_attr_2(RI_ATT2_N_VALUES)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54141"></A>      integer   i</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54142"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54143"></A>      do 10 i = 1, RI_ATT2_N_VALUES</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54144"></A>         ri_attr_2(i) = i</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54145"></A>10    continue </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54146"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54147"></A>C**** End of variable declaration ************************************</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54148"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54149"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54150"></A>C     Open the HDF file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54151"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54152"></A>      file_id = hopen(FILE_NAME, DFACC_WRITE, 0)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54153"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54154"></A>C     Initialize the GR interface.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54155"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54156"></A>      gr_id = mgstart(file_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54157"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54158"></A>C     Set two file attributes to the file with names, data type, numbers of</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54159"></A>C     values, and values of attributes specified.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54160"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54161"></A>      status = mgscatt(gr_id, F_ATT1_NAME, DFNT_CHAR8, </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54162"></A>     +                 F_ATT1_N_VALUES, F_ATT1_VAL)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54163"></A>      status = mgscatt(gr_id, F_ATT2_NAME, DFNT_CHAR8, </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54164"></A>     +                 F_ATT2_N_VALUES, F_ATT2_VAL)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54165"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54166"></A>C     Obtain the index of the image named IMAGE_NAMR.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54167"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54168"></A>      ri_index = mgn2ndx(gr_id, IMAGE_NAME)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54169"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54170"></A>C     Obtain the identifier of this image. </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54171"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54172"></A>      ri_id = mgselct(gr_id, ri_index)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54173"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54174"></A>C     Set two attributes of the image with names, data types, number of</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54175"></A>C     values, and values of the attributes specified. </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54176"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54177"></A>      status = mgscatt(ri_id, RI_ATT1_NAME, DFNT_CHAR8, </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54178"></A>     +                 RI_ATT1_N_VALUES, RI_ATT1_VAL) </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54179"></A>      status = mgsnatt(ri_id, RI_ATT2_NAME, DFNT_INT16, </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54180"></A>     +                 RI_ATT2_N_VALUES, ri_attr_2)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54181"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54182"></A>C     Terminate access to the image and to the GR interface,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54183"></A>C     and close the HDF file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54184"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54185"></A>      status = mgendac(ri_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54186"></A>      status = mgend(gr_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54187"></A>      status = hclose(file_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54188"></A>      end</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54189"></A>&nbsp;</P>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-11685"></A>	8.10.3	<A NAME="50593878_11523"></A>Query<A NAME="50593878_marker-22632"></A>ing User-Defined Attributes: GRfindattr and GRattrinfo</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-31651"></A>Each attribute associated with an object has a uniqu<A NAME="50593878_marker-31650"></A>e <EM CLASS="Definition">
attribute index</EM>
, a value ranging from 0 to the total number of attributes attached to the object - 1. Given a GR interface or raster image identifier and an attribute name, <EM CLASS="FunctionName">
GRfindattr</EM>
<A NAME="50593878_marker-31652"></A> will return a valid attribute index of the file or raster image attribute if the attribute exists. The attribute index can then be used to retrieve information about the attribute or its values. Given a GR interface or raster image identifier and a valid attribute index, <EM CLASS="FunctionName">
GRattrinfo </EM>
<A NAME="50593878_marker-31653"></A>returns the name, data type, and number of values for the file or raster image attribute if the attribute exists.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-11688"></A>The syntax for <EM CLASS="FunctionName">
GRfindattr</EM>
 and <EM CLASS="FunctionName">
GRattrinfo</EM>
 is as follows:</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-11689"></A><EM CLASS="syntaxLang">
C:</EM>
		attr_index = GRfindattr(obj_id, attr_name);</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-11690"></A>		status = GRattrinfo(obj_id, attr_index, attr_name, &amp;data_type, &amp;n_values);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-14921"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	attr_index = mgfndat(obj_id, attr_name)</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-14922"></A>		status = mgatinf(obj_id, attr_index, attr_name, data_type, n_values)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-54924"></A>The parameter <EM CLASS="VarName">
obj_id</EM>
 is either a GR interface identifier or a raster image identifier. The parameter <EM CLASS="VarName">
attr_name</EM>
 specifies the name of the attribute. The parameter <EM CLASS="VarName">
attr_index</EM>
 specifies the index of the attribute to be read. The attribute index is a zero-based integer and must be less than the total number of attributes assigned to the specified object. The parameter <EM CLASS="VarName">
data_type</EM>
 specifies the data type of the attribute. And the parameter <EM CLASS="VarName">
n_values</EM>
 specifies the number of attribute values.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-54932"></A><EM CLASS="FunctionName">
GRfindattr</EM>
 returns the attribute index if successful and <EM CLASS="VarName">
FAIL</EM>
 (or <EM CLASS="VarName">
-1</EM>
) otherwise.  <EM CLASS="FunctionName">
GRattrinfo</EM>
 returns <EM CLASS="VarName">
SUCCEED</EM>
 (or <EM CLASS="VarName">
0</EM>
) if successful and <EM CLASS="VarName">
FAIL</EM>
 (or <EM CLASS="VarName">
-1</EM>
) otherwise.  The parameters for <EM CLASS="FunctionName">
GRfindattr</EM>
 and <EM CLASS="FunctionName">
GRattrinfo</EM>
 are further described in <A HREF="UG_html-8.htm#50593878_15192" CLASS="XRef">Table 8I</A>.</P>
</DIV>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-54927"></A>	8.10.4	<A NAME="50593878_17499"></A>Read<A NAME="50593878_marker-54926"></A>ing User-defined Attributes: GRgetattr</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-54929"></A><EM CLASS="FunctionName">
GRgetattr</EM>
<A NAME="50593878_marker-54928"></A> reads the values of an attribute assigned to the object identified by the parameter <EM CLASS="VarName">
obj_id</EM>
. The syntax for <EM CLASS="FunctionName">
GRgetattr</EM>
 is as follows:</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-11702"></A><EM CLASS="syntaxLang">
C:</EM>
		status = GRgetattr(obj_id, attr_index, values);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-11704"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	status = mggnatt(obj_id, attr_index, values)</P>
<P CLASS="syntax-or-top">
<A NAME="50593878_pgfId-33550"></A>	<EM CLASS="syntaxLang">
OR</EM>
	status = mggcatt(obj_id, attr_index, values)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-11705"></A>The parameter <EM CLASS="VarName">
obj_id</EM>
 is either a GR interface identifier or a raster image identifier. The parameter <EM CLASS="VarName">
attr_index</EM>
 specifies the index of the attribute to be read. The attribute index is a zero-based integer and must be less than the total number of attributes assigned to the specified object.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-14942"></A>It is assumed that the buffer <EM CLASS="VarName">
values</EM>
, allocated to hold the attribute values, is large enough to hold the data; if not, the data read will be truncated to the size of the buffer. The size of the buffer should be at least <EM CLASS="VarName">
n_values*sizeof(data_type)</EM>
 bytes long. If an attribute contains multiple values, <EM CLASS="FunctionName">
GRgetattr</EM>
 will return all of them. It is not possible to read a subset of values. </P>
<P CLASS="Body">
<A NAME="50593878_pgfId-22926"></A>Note that the FORTRAN-77 version of <EM CLASS="FunctionName">
GRgetattr</EM>
 has two routines; <EM CLASS="FunctionName">
mggnatt</EM>
 reads numeric attribute data and <EM CLASS="FunctionName">
mggcatt</EM>
 reads character attribute data.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-33545"></A><EM CLASS="FunctionName">
GRgetattr</EM>
 returns <EM CLASS="VarName">
SUCCEED</EM>
 (or <EM CLASS="VarName">
0</EM>
) if successful and <EM CLASS="VarName">
FAIL</EM>
 (or <EM CLASS="VarName">
-1</EM>
) otherwise.  The parameters for <EM CLASS="FunctionName">
GRgetattr </EM>
are further described in <A HREF="UG_html-8.htm#50593878_15192" CLASS="XRef">Table 8I</A>.</P>
<DIV>
<H6 CLASS="Table">
<A NAME="50593878_pgfId-11895"></A><DIV>
<IMG SRC="UG_html-51.gif" ALT="">
</DIV>
<A NAME="50593878_15192"></A>GRs<A NAME="50593878_marker-22638"></A>etattr, GRfin<A NAME="50593878_marker-22639"></A>dattr, GR<A NAME="50593878_marker-22640"></A>attrinfo, and <A NAME="50593878_marker-22641"></A>GRgetattr Parameter Lists</H6>
<TABLE>
<TR>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-16356"></A>Routine Name</P>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-29957"></A>[Return Type]</H6>
<P CLASS="TableHead">
<A NAME="50593878_pgfId-16357"></A>(FORTRAN-77)</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-16359"></A>Parameter</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-16363"></A>Parameter Type</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-16365"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-16371"></A>C</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-16373"></A>FORTRAN-77</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="5" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-16377"></A>GRsetattr</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-29958"></A>[intn]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-16378"></A>(mgsnatt/mgscatt)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16380"></A>obj_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16382"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16384"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-16386"></A>GR interface or raster image identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16390"></A>attr_name</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16392"></A>char *</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16394"></A>character*(*)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-16396"></A>Name assigned to the attribute</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16400"></A>data_type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16402"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16404"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-16406"></A>Data type of the attribute</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16410"></A>n_values</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16412"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16414"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-16416"></A>Number of values in the attribute</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16420"></A>values</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16422"></A>VOIDP</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-22831"></A>&lt;valid numeric data type&gt;(*)/character*(*)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-16426"></A>Buffer with the attribute values</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="2" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-16428"></A>GRfindattr</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-29959"></A>[int32]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-16429"></A>(mgfndat)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16431"></A>obj_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16433"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16435"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-16437"></A>GR interface or raster image identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16441"></A>attr_name</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16443"></A>char *</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16445"></A>character*(*)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-16447"></A>Name of the attribute</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="5" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-16449"></A>GRattrinfo</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-29960"></A>[intn]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-16450"></A>(mgatinf)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16452"></A>obj_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16454"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16456"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-16458"></A>GR interface or raster image identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16462"></A>attr_index</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16464"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16466"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-16468"></A>Index for the attribute to be read</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16472"></A>attr_name</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16474"></A>char *</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16476"></A>character*(*)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-16478"></A>Name of the attribute</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16482"></A>data_type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16484"></A>int32 *</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16486"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-16488"></A>Data type of the attribute values</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16492"></A>n_values</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16494"></A>int32 *</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16496"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-16498"></A> Total number of values in the attribute</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="3" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-16500"></A>GRgetattr</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-29961"></A>[intn]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-16501"></A>(mggnatt/</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-22833"></A>mggcatt)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16503"></A>obj_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16505"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16507"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-16509"></A>GR interface or raster image identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16513"></A>attr_index</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16515"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16517"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-16519"></A>Index for the attribute to be read</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16523"></A>values</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-16525"></A>VOIDP</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-22836"></A>&lt;valid numeric data type&gt;(*)/character*(*)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-16529"></A>Buffer for the attribute values</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Example">
<A NAME="50593878_pgfId-11896"></A><DIV>
<IMG SRC="UG_html-51.gif" ALT="">
</DIV>
Obtaining File and Image Attributes.</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-49679"></A>This example illustrates the use of the routines <EM CLASS="FunctionName">
GRattrinfo/mgatinf</EM>
, <EM CLASS="FunctionName">
GRfindattr/mgfndat</EM>
, and <EM CLASS="FunctionName">
GRgetattr/mggnatt/mggcatt</EM>
 to extract information and values of file and image attributes that were set by the program in Example 5.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-49684"></A>In this example, the program gets the information about each file attribute, then extracts its values.  The program then selects the second image in the file, finds the attribute named &quot;Image Attribute 2&quot;, obtains the data type and the number of values in the attribute, and extracts its stored values.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H4 CLASS="Code-C-Title">
<A NAME="50593878_pgfId-25306"></A><DIV>
<IMG SRC="UG_html-53.gif" ALT="">
</DIV>
C:		</H4>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-49861"></A>#include &quot;hdf.h&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54193"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54194"></A>#define  FILE_NAME       &quot;General_RImages.hdf&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54195"></A>#define  RI_ATTR_NAME    &quot;Image Attribute 2&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54196"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54197"></A>main( ) </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54198"></A>{</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54199"></A>   /************************* Variable declaration **************************/</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54200"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54201"></A>   intn   status;          /* status for functions returning an intn */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54202"></A>   int32  gr_id, ri_id, file_id,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54203"></A>          f_att_index,     /* index of file attributes */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54204"></A>          ri_att_index,    /* index of raster image attributes */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54205"></A>          data_type,       /* image data type */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54206"></A>          n_values,        /* number of values in an attribute */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54207"></A>          value_index,     /* index of values in an attribute */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54208"></A>          n_rimages,       /* number of raster images in the file */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54209"></A>          n_file_attrs;    /* number of file attributes */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54210"></A>   char   attr_name[MAX_GR_NAME];  /* buffer to hold the attribute name     */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54211"></A>   VOIDP  data_buf;                /* buffer to hold the attribute values   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54212"></A>   int16 *int_ptr;      /* int16 pointer to point to a void data buffer     */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54213"></A>   char8 *char_ptr;     /* char8 pointer to point to a void data buffer     */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54214"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54215"></A>   /********************** End of variable declaration **********************/</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54216"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54217"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54218"></A>   * Open the HDF file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54219"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54220"></A>   file_id = Hopen (FILE_NAME, DFACC_READ, 0);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54221"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54222"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54223"></A>   * Initialize the GR interface.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54224"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54225"></A>   gr_id = GRstart (file_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54226"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54227"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54228"></A>   * Determine the number of attributes in the file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54229"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54230"></A>   status = GRfileinfo (gr_id, &amp;n_rimages, &amp;n_file_attrs);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54231"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54232"></A>   if (status != FAIL &amp;&amp; n_file_attrs &gt; 0)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54233"></A>   {</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54234"></A>      for (f_att_index = 0; f_att_index &lt; n_file_attrs; f_att_index++)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54235"></A>      {</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54236"></A>         /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54237"></A>         * Get information about the current file attribute.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54238"></A>         */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54239"></A>         status = GRattrinfo (gr_id, f_att_index, attr_name, &amp;data_type, </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54240"></A>                              &amp;n_values);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54241"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54242"></A>         /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54243"></A>         * Allocate a buffer to hold the file attribute data.  In this example,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54244"></A>         * knowledge about the data type is assumed to be available from </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54245"></A>         * the previous example for simplicity.  In reality, the size</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54246"></A>         * of the type must be determined based on the machine where the </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54247"></A>         * program resides.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54248"></A>         */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54249"></A>         if (data_type == DFNT_CHAR8)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54250"></A>         {</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54251"></A>            data_buf = malloc (n_values * sizeof (char8));</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54252"></A>            if (data_buf == NULL)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54253"></A>            {</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54254"></A>               printf (&quot;Unable to allocate space for attribute data.\n&quot;);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54255"></A>               exit (1);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54256"></A>            }</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54257"></A>         }</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54258"></A>         else</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54259"></A>         {</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54260"></A>            printf (&quot;Unable to determine data type to allocate data buffer.\n&quot;);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54261"></A>            exit (1);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54262"></A>         }</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54263"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54264"></A>         /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54265"></A>         * Read and display the attribute values.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54266"></A>         */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54267"></A>         status = GRgetattr (gr_id, f_att_index, (VOIDP)data_buf);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54268"></A>         char_ptr = (char8 *) data_buf;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54269"></A>         printf (&quot;Attribute %s: &quot;, attr_name);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54270"></A>         for (value_index = 0; value_index &lt; n_values; value_index++)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54271"></A>            printf (&quot;%c&quot;, char_ptr[value_index]);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54272"></A>         printf (&quot;\n&quot;);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54273"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54274"></A>         /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54275"></A>         * Free the space allocated for the data buffer.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54276"></A>         */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54277"></A>         free (data_buf);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54278"></A>      } /* for */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54279"></A>   } /* if */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54280"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54281"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54282"></A>   * Select the second image in the file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54283"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54284"></A>   ri_id = GRselect (gr_id, 1);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54285"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54286"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54287"></A>   * Find the image attribute named RI_ATTR_NAME.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54288"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54289"></A>   ri_att_index = GRfindattr (ri_id, RI_ATTR_NAME);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54290"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54291"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54292"></A>   * Get information about the attribute.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54293"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54294"></A>   status = GRattrinfo (ri_id, ri_att_index, attr_name, &amp;data_type, &amp;n_values);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54295"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54296"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54297"></A>   * Allocate a buffer to hold the file attribute data.  As mentioned above,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54298"></A>   * knowledge about the data type is assumed to be available from</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54299"></A>   * the previous example for simplicity.  In reality, the size of the </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54300"></A>   * type must be determined based on the machine where the program resides.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54301"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54302"></A>   if (data_type == DFNT_INT16)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54303"></A>      data_buf = malloc (n_values * sizeof (int16));</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54304"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54305"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54306"></A>   * Read and display the attribute values.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54307"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54308"></A>   status = GRgetattr (ri_id, ri_att_index, (VOIDP)data_buf);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54309"></A>   printf (&quot;\nAttribute %s: &quot;, RI_ATTR_NAME);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54310"></A>   int_ptr = (int16 *)data_buf;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54311"></A>   for (value_index = 0; value_index &lt; n_values; value_index++)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54312"></A>      printf (&quot;%d &quot;, int_ptr[value_index]);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54313"></A>   printf (&quot;\n&quot;);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54314"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54315"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54316"></A>   * Free the space allocated for the data buffer.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54317"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54318"></A>   free (data_buf);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54319"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54320"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54321"></A>   * Terminate access to the raster image and to the GR interface, and</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54322"></A>   * close the file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54323"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54324"></A>   status = GRendaccess (ri_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54325"></A>   status = GRend (gr_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54326"></A>   status = Hclose (file_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54327"></A>}</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54328"></A>&nbsp;</P>
</DIV>
<DIV>
<H4 CLASS="Code-F-Title">
<A NAME="50593878_pgfId-25308"></A><DIV>
<IMG SRC="UG_html-53.gif" ALT="">
</DIV>
FORTRAN: 	</H4>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-49970"></A>      program  get_attribute</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54332"></A>      implicit none</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54333"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54334"></A>C     Parameter declaration</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54335"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54336"></A>      character*19 FILE_NAME</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54337"></A>      character*17 RI_ATTR_NAME</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54338"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54339"></A>      parameter (FILE_NAME    = ’General_RImages.hdf’,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54340"></A>     +           RI_ATTR_NAME  = ’Image Attribute 2’)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54341"></A>      integer DFACC_READ, DFNT_INT16, DFNT_CHAR8</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54342"></A>      parameter (DFACC_READ   = 1,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54343"></A>     +           DFNT_CHAR8   = 4,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54344"></A>     +           DFNT_INT16   = 22)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54345"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54346"></A>C     Function declaration</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54347"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54348"></A>      integer hopen, hclose</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54349"></A>      integer mgstart, mgfinfo, mgatinf, mggcatt, mggnatt , mgfndat,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54350"></A>     +        mgselct, mgendac, mgend </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54351"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54352"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54353"></A>C**** Variable declaration *******************************************</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54354"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54355"></A>      integer      status</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54356"></A>      integer      file_id, gr_id, ri_id</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54357"></A>      integer      f_att_index, ri_att_index, data_type, n_values </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54358"></A>      integer      n_rimages, n_file_attrs </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54359"></A>      integer*2    int_buf(10)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54360"></A>      character*17 attr_name</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54361"></A>      character*80 char_buf</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54362"></A>      integer      i</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54363"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54364"></A>C**** End of variable declaration ************************************</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54365"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54366"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54367"></A>C     Open the HDF file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54368"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54369"></A>      file_id = hopen(FILE_NAME, DFACC_READ, 0)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54370"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54371"></A>C     Initialize the GR interface.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54372"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54373"></A>      gr_id = mgstart(file_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54374"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54375"></A>C     Determine the number of attributes in the file. </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54376"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54377"></A>      status = mgfinfo(gr_id, n_rimages, n_file_attrs)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54378"></A>      if ((status .NE. -1) .AND. (n_file_attrs .GT. 0)) then</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54379"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54380"></A>         do 10 f_att_index = 0, n_file_attrs-1</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54381"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54382"></A>C        Get information about the current file attribute.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54383"></A>C </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54384"></A>         status = mgatinf(gr_id, f_att_index, attr_name, data_type,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54385"></A>     +                    n_values)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54386"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54387"></A>C        Check whether data type is DFNT_CHAR8 in order to use allocated buffer.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54388"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54389"></A>         if(data_type .NE. DFNT_CHAR8) then</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54390"></A>            write(*,*) </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54391"></A>     +      ’Unable to determine data type to use allocated buffer’</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54392"></A>         else</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54393"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54394"></A>C           Read and display the attribute values.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54395"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54396"></A>            status = mggcatt(gr_id, f_att_index, char_buf)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54397"></A>            write(*,*) ’Attribute ’, attr_name, ’ : ’, </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54398"></A>     +                 char_buf(1:n_values)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54399"></A>         endif</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54400"></A>10       continue</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54401"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54402"></A>      endif</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54403"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54404"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54405"></A>C     Select the second image in the file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54406"></A>C </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54407"></A>      ri_id = mgselct(gr_id, 1) </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54408"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54409"></A>C     Find the image attribute named RI_ATTR_NAME. </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54410"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54411"></A>      ri_att_index = mgfndat(ri_id, RI_ATTR_NAME)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54412"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54413"></A>C     Get information about the attribute.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54414"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54415"></A>      status = mgatinf(ri_id, ri_att_index, attr_name, data_type,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54416"></A>     +                 n_values)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54417"></A>C      </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54418"></A>C     Read and display attribute values.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54419"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54420"></A>      status = mggnatt(ri_id, ri_att_index, int_buf)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54421"></A>      write(*,*) ’Attributes :’, (int_buf(i), i = 1, n_values)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54422"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54423"></A>C     Terminate access to the image and to the GR interface,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54424"></A>C     and close the HDF file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54425"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54426"></A>      status = mgendac(ri_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54427"></A>      status = mgend(gr_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54428"></A>      status = hclose(file_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54429"></A>      end</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54430"></A><A NAME="50593878_marker-22625"></A>&nbsp;</P>
<DIV>
<H5 CLASS="Heading2">
<A NAME="50593878_pgfId-12074"></A>	8.11	<A NAME="50593878_31041"></A>Readi<A NAME="50593878_marker-22642"></A>ng and Writing Palette Data Using the GR Interface<DIV>
<IMG SRC="UG_html-50.gif" ALT="">
</DIV>
</H5>
<P CLASS="Body">
<A NAME="50593878_pgfId-38063"></A>The GR API library includes routines that read, write, and access information about palette data attached to GR images. Although this functionality is also provided by the HDF Palette API library, it is not a recommended practice to use the Palette API to access and manipulate palette objects created by GR interface routines.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-38064"></A>The routines are named <EM CLASS="FunctionName">
GRgetlutid</EM>
, <EM CLASS="FunctionName">
GRluttoref</EM>
, <EM CLASS="FunctionName">
GRgetlutinfo</EM>
, <EM CLASS="FunctionName">
GRwritelut</EM>
, <EM CLASS="FunctionName">
GRreqlutil</EM>
, and<EM CLASS="FunctionName">
 GRreadlut</EM>
. Note that the routine names use the ter<A NAME="50593878_marker-38065"></A>m <EM CLASS="Definition">
LUT</EM>
 to refer to palettes; LUT stands for col<A NAME="50593878_marker-38066"></A>or <EM CLASS="Definition">
lookup tables</EM>
. </P>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-12076"></A>	8.11.1	<A NAME="50593878_13955"></A>Obtaining a <A NAME="50593878_marker-22646"></A>Palette Identifier: GRgetlutid</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-15638"></A>Given a palette index, the routine <EM CLASS="FunctionName">
GRgetlutid</EM>
 is used to get the palette identifier for the specified palette.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-55002"></A>The <EM CLASS="FunctionName">
GRgetlutid</EM>
<A NAME="50593878_marker-22647"></A> function takes two arguments, <EM CLASS="VarName">
ri_id</EM>
, the raster image identifier of the image that has the palette attached to it, and <EM CLASS="VarName">
lut_index</EM>
, the index of the palette, and returns the value of the palette identifier corresponding to the specified image. The syntax of <EM CLASS="FunctionName">
GRgetlutid</EM>
 is as follows:</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-15639"></A><EM CLASS="syntaxLang">
C:</EM>
		pal_id = GRgetlutid(ri_id, lut_index);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-15641"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	pal_id = mggltid(ri_id, lut_index)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-54987"></A><EM CLASS="FunctionName">
GRgetlutid</EM>
 returns the value of the palette identifier if successful and <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
) otherwise. The <EM CLASS="FunctionName">
GRgetlutid</EM>
 parameters are further discussed in <A HREF="UG_html-8.htm#50593878_14769" CLASS="XRef">Table 8J</A>.</P>
</DIV>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-66209"></A>	8.11.2	Obtaining the Number of Palettes Associated with an Image: GRgetnluts</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-66210"></A>Given an image identifier, <EM CLASS="FunctionName">
GRgetnluts</EM>
 is used to determne the number of palettes currently associated with an image.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-66213"></A>The <EM CLASS="FunctionName">
GRgetnluts</EM>
 function takes one argument, <EM CLASS="VarName">
ri_id</EM>
, a raster image identifier, and returns the number of palettes associated with that imare.  The syntax of GRgetnluts is as follows:</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-66220"></A><EM CLASS="syntaxLang">
C:</EM>
		n_luts = GRgetnluts(ri_id);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-66221"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	n_luts = mggnluts(ri_id)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-66222"></A><EM CLASS="FunctionName">
GRgetnluts</EM>
 returns the number of palettes associated with the identified image if successful and <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
) otherwise. The <EM CLASS="FunctionName">
GRgetnluts</EM>
 parameters are further discussed in <A HREF="UG_html-8.htm#50593878_14769" CLASS="XRef">Table 8J</A>.</P>
</DIV>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-23231"></A>	8.11.3	<A NAME="50593878_22530"></A>Obtaining the Reference Number of a Specified Palette: GRluttoref</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-23234"></A>Given a palette identifier, <EM CLASS="FunctionName">
GRluttoref</EM>
 can be used to obtain the reference number of the specified palette.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-55083"></A>The <EM CLASS="FunctionName">
GRluttoref</EM>
<A NAME="50593878_marker-23232"></A><A NAME="50593878_marker-23233"></A> routine takes one argument, <EM CLASS="VarName">
pal_id</EM>
, a palette identifier, and returns the reference number of the palette. <EM CLASS="FunctionName">
GRluttoref</EM>
 is commonly used to annotate the palette or to include the palette within a vgroup. The syntax of <EM CLASS="FunctionName">
GRgetlutid</EM>
 is as follows:</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-35229"></A><EM CLASS="syntaxLang">
C:</EM>
		pal_ref = GRluttoref(pal_id);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-35230"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	pal_ref = mglt2rf(pal_id)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-55006"></A><EM CLASS="FunctionName">
GRluttoref</EM>
 returns the reference number of the palette if successful and <EM CLASS="DefName">
0</EM>
 otherwise. The <EM CLASS="FunctionName">
GRluttoref</EM>
 parameters are further discussed in <A HREF="UG_html-8.htm#50593878_14769" CLASS="XRef">Table 8J</A>.</P>
<DIV>
<H6 CLASS="Table">
<A NAME="50593878_pgfId-34782"></A><DIV>
<IMG SRC="UG_html-51.gif" ALT="">
</DIV>
<A NAME="50593878_14769"></A>GRgetlutid, GRgetlutinfo, and GRlut<A NAME="50593878_marker-34689"></A>toref Parameter Lists</H6>
<TABLE>
<TR>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-34692"></A>Routine Name</P>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-34693"></A>[Return Type]</H6>
<P CLASS="TableHead">
<A NAME="50593878_pgfId-34694"></A>(FORTRAN-77)</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-34696"></A>Parameter</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-34698"></A>Parameter Type</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-34702"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-34708"></A>C</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-34710"></A>FORTRAN-77</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="2" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-34714"></A>GRgetlutid</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-34715"></A>[int32]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-34716"></A>(mggltid)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-34718"></A>ri_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-34720"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-34722"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-34724"></A>Raster image identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-34728"></A>lut_index</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-34730"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-34732"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-34734"></A>Palette index</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-34736"></A>GRluttoref</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-34737"></A>[uint16]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-34738"></A>(mglt2rf)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-34740"></A>pal_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-34742"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-34744"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-34746"></A>Palette identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-66261"></A>GRgetnluts</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-66262"></A>[intn]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-66263"></A>(mggnluts)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-66265"></A>ri_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-66267"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-66269"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-66271"></A>Raster image identifier</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-35164"></A>	8.11.4	<A NAME="50593878_15860"></A>Obtain<A NAME="50593878_marker-35163"></A>ing Palette Information: GRgetlutinfo</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-35166"></A>Given a palette identifier, <EM CLASS="FunctionName">
GRgetlutinfo</EM>
<A NAME="50593878_marker-55041"></A> retrieves information about the palette and its components.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-55039"></A>The <EM CLASS="FunctionName">
GRgetlutinfo</EM>
<A NAME="50593878_marker-35165"></A> function takes one input argument, <EM CLASS="VarName">
pal_id</EM>
, the identifier of the palette, and several return parameters.  The return parameters are <EM CLASS="VarName">
n_comps</EM>
, the number of components of the palette; <EM CLASS="VarName">
data_type</EM>
, the data type of the palette data; <EM CLASS="VarName">
interlace_mode</EM>
, the interlace mode of the stored palette data; and <EM CLASS="VarName">
num_entries</EM>
, the number of entries in the palette. The syntax of <EM CLASS="FunctionName">
GRgetlutinfo</EM>
 is as follows:</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-35168"></A><EM CLASS="syntaxLang">
C:</EM>
		status = GRgetlutinfo(pal_id, &amp;n_comps, &amp;data_type, &amp;interlace_mode, &amp;num_entries);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-35169"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	status = mgglinf(pal_id, n_comps, data_type, interlace_mode, num_entries)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-55023"></A><EM CLASS="FunctionName">
GRgetlutinfo</EM>
 returns <EM CLASS="DefName">
SUCCEED</EM>
 (or <EM CLASS="DefName">
0</EM>
) if successful and <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
) otherwise. The <EM CLASS="FunctionName">
GRgetlutinfo</EM>
 parameters are further discussed in <A HREF="UG_html-8.htm#50593878_14769" CLASS="XRef">Table 8J</A>.</P>
</DIV>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-34785"></A>	8.11.5	<A NAME="50593878_37998"></A>Writin<A NAME="50593878_marker-34784"></A>g Palette Data: GRwritelut</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-32744"></A><EM CLASS="FunctionName">
GRwritelut</EM>
<A NAME="50593878_marker-32743"></A> writes palette data into the palette identified by the parameter <EM CLASS="VarName">
pal_id</EM>
. The syntax of <EM CLASS="FunctionName">
GRwritelut</EM>
 is as follows:</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-15743"></A><EM CLASS="syntaxLang">
C:</EM>
		status = GRwritelut(pal_id, n_comps, data_type, interlace_mode, num_entries, pal_data);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-15752"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	status = mgwrlut(pal_id, n_comps, data_type, interlace_mode, num_entries, pal_data)</P>
<P CLASS="syntax-or-top">
<A NAME="50593878_pgfId-15653"></A><EM CLASS="syntaxLang">
	OR</EM>
	status = mgwclut(pal_id, n_comps, data_type, interlace_mode, num_entries, pal_data)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-38388"></A>The parameter <EM CLASS="VarName">
n_comps</EM>
 specifies the number of pixel components in the palette; it must have a value of at least 1. The parameter <EM CLASS="VarName">
data_type</EM>
 specifies the data type of the palette data. Refer to <A HREF="UG_html-2.htm#50593872_13047" CLASS="XRef">Standard HDF Data Types and Flags</A> for all data types supported by HDF.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-133060"></A>The parameter <EM CLASS="VarName">
interlace_mode</EM>
 specifies the interlacing in which the palette is to be written. The valid values of <EM CLASS="VarName">
interlace_mode</EM>
 are: <EM CLASS="DefName">
MFGR_INTERLACE_PIXEL</EM>
 (or <EM CLASS="DefName">
0</EM>
), <EM CLASS="DefName">
MFGR_INTERLACE_LINE</EM>
 (or <EM CLASS="DefName">
1</EM>
) and <EM CLASS="DefName">
MFGR_INTERLACE_COMPONENT</EM>
 (or <EM CLASS="DefName">
2</EM>
). Refer to <A HREF="UG_html-8.htm#50593878_19873" CLASS="XRef">Accessing Images and Files: GRstart, GRselect, and GRcreate</A> for further information.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-155569"></A>The parameter <EM CLASS="VarName">
num_entries</EM>
 specifies the number of entries in the palette. The buffer <EM CLASS="VarName">
pal_data</EM>
 contains the palette data.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-155570"></A>Note that, currently only “old-style” palettes are supported, i.e <EM CLASS="VarName">
ncomp</EM>
=<EM CLASS="DefName">
3</EM>
, <EM CLASS="VarName">
data_type</EM>
=<EM CLASS="DefName">
uint8</EM>
, <EM CLASS="VarName">
interlace_mode</EM>
=<EM CLASS="DefName">
MFGR_INTERLACE_PIXEL</EM>
, and <EM CLASS="VarName">
num_entries</EM>
=<EM CLASS="DefName">
256</EM>
.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-155571"></A>Note that the FORTRAN-77 version of <EM CLASS="FunctionName">
GRwritelut</EM>
 has two routines; <EM CLASS="FunctionName">
mgwrlut</EM>
 writes buffered numeric palette data and <EM CLASS="FunctionName">
mgwclut</EM>
 writes buffered character palette data.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-38439"></A><EM CLASS="FunctionName">
GRwritelut</EM>
 returns either <EM CLASS="DefName">
SUCCEED</EM>
 (or <EM CLASS="DefName">
0</EM>
) or <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
). The parameters of this routine are further defined in <A HREF="UG_html-8.htm#50593878_16361" CLASS="XRef">GRgetlutid, GRwritelut, GRreqlutil, and GRreadlut Parameter Lists</A>.</P>
</DIV>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-34422"></A>	8.11.6	Setting the Interlace Mode for a Palette: GRreqlutil </H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-35880"></A><EM CLASS="FunctionName">
GRreqlutil</EM>
<A NAME="50593878_marker-34423"></A> sets the interlace mode for the next palette to be read. The syntax of <EM CLASS="FunctionName">
GRreqlutil</EM>
 is as follows:</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-43495"></A><EM CLASS="syntaxLang">
C:</EM>
		status = GRreqlutil(pal_id, interlace_mode);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-43496"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	status = mgrltil(pal_id, interlace_mode)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-43532"></A>The parameter <EM CLASS="VarName">
interlace_mode</EM>
 specifies the interlacing that will be in effect for the next palette read operation. The valid values of <EM CLASS="VarName">
interlace_mode</EM>
 are: <EM CLASS="DefName">
MFGR_INTERLACE_PIXEL</EM>
 (or <EM CLASS="DefName">
0</EM>
), <EM CLASS="DefName">
MFGR_INTERLACE_LINE</EM>
 (or <EM CLASS="DefName">
1</EM>
) and <EM CLASS="DefName">
MFGR_INTERLACE_COMPONENT</EM>
 (or <EM CLASS="DefName">
2</EM>
). Refer to <A HREF="UG_html-8.htm#50593878_19873" CLASS="XRef">Accessing Images and Files: GRstart, GRselect, and GRcreate</A> for further information.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-43593"></A><EM CLASS="FunctionName">
GRreqlutil</EM>
 may be called at anytime before the read operation of the specified palette. In addition, it may be called more than once; the interlace mode setting specified by the last call to the routine will be used for the next read operation.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-34442"></A><EM CLASS="FunctionName">
GRreqlutil</EM>
 returns either <EM CLASS="DefName">
SUCCEED</EM>
 (or <EM CLASS="DefName">
0</EM>
) or <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
). The parameters of this routine are further defined in <A HREF="UG_html-8.htm#50593878_16361" CLASS="XRef">GRgetlutid, GRwritelut, GRreqlutil, and GRreadlut Parameter Lists</A>.</P>
</DIV>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-43613"></A>	8.11.7	<A NAME="50593878_24546"></A>Reading<A NAME="50593878_marker-43612"></A> Palette Data: GRreadlut</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-43615"></A><EM CLASS="FunctionName">
GRreadlut</EM>
<A NAME="50593878_marker-43614"></A> reads data from the palette identified by the parameter <EM CLASS="VarName">
pal_id</EM>
. The syntax of <EM CLASS="FunctionName">
GRreadlut</EM>
 is as follows:</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-15800"></A><EM CLASS="syntaxLang">
C:</EM>
		status = GRreadlut(pal_id, pal_data);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-15810"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	status = mgrdlut(pal_id, pal_data)</P>
<P CLASS="syntax-or-top">
<A NAME="50593878_pgfId-33529"></A><EM CLASS="syntaxLang">
	OR</EM>
	status = mgrclut(pal_id, pal_data)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-22889"></A>The read data will be stored in the buffer <EM CLASS="VarName">
pal_data</EM>
, which is assumed to be sufficient to store the read palette data. The sufficient amount of space needed can be determined using the routine <EM CLASS="FunctionName">
GRgetlutinfo</EM>
. The palette data is read according to the interlacing mode set by the last call to <EM CLASS="FunctionName">
GRreqlutil</EM>
.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-43634"></A>Note that the FORTRAN-77 version of <EM CLASS="FunctionName">
GRreadlut</EM>
 has two routines; <EM CLASS="FunctionName">
mgrdlut</EM>
 reads numeric palette data and <EM CLASS="FunctionName">
mgrclut</EM>
 reads character palette data.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-43655"></A><EM CLASS="FunctionName">
GRreadlut</EM>
 returns either <EM CLASS="DefName">
SUCCEED</EM>
 (or <EM CLASS="DefName">
0</EM>
) or <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
). The parameters of this routine are further defined in <A HREF="UG_html-8.htm#50593878_16361" CLASS="XRef">Table 8K</A>.</P>
<DIV>
<H6 CLASS="Table">
<A NAME="50593878_pgfId-15987"></A><DIV>
<IMG SRC="UG_html-51.gif" ALT="">
</DIV>
<A NAME="50593878_16361"></A>GRgetlu<A NAME="50593878_marker-22654"></A>tid, G<A NAME="50593878_marker-22656"></A>Rwritelut, GRreqlutil, and<A NAME="50593878_marker-22657"></A> GRreadlut Parameter Lists</H6>
<TABLE>
<TR>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-15813"></A>Routine Name </P>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-29966"></A>[Return Type]</H6>
<P CLASS="TableHead">
<A NAME="50593878_pgfId-15814"></A>(FORTRAN-77)</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-15816"></A>Parameter</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-15818"></A>Parameter Type</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-15822"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-15828"></A>C</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-15830"></A>FORTRAN-77</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="5" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-35173"></A>GRgetlutinfo</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-35174"></A>[intn]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-35175"></A>(mgglinf)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35177"></A>pal_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35179"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35181"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-35183"></A>Palette identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35187"></A>n_comps</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35189"></A>int32*</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35191"></A>integer </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-35193"></A>Number of components in each palette element</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35197"></A>data_type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35199"></A>int32*</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35201"></A>integer </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-35203"></A>Data type of the palette data</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35207"></A>interlace_mode</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35209"></A>int32*</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35211"></A>integer </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-35213"></A>Interlace mode of the palette data</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35217"></A>num_entries</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35219"></A>int32*</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-35221"></A>integer </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-35223"></A>Buffer for the size of the palette</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="6" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-15885"></A>GRwritelut</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-29968"></A>[intn]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-15886"></A>(mgwrlut/</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-22885"></A>mgwclut)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15888"></A>pal_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15890"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15892"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-15894"></A>Palette identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15898"></A>n_comps</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15900"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15902"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-15904"></A>Number of components in each palette element</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15908"></A>data_type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15910"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15912"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-15914"></A>Type of the palette data</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15918"></A>interlace_mode</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15920"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15922"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-15924"></A>Interlace mode of the palette data</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15928"></A>num_entries</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15930"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15932"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-15934"></A>Number of entries in the palette</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15938"></A>pal_data</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15940"></A>VOIDP</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-22886"></A>&lt;valid numeric data type&gt;(*)/character*(*)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-15944"></A>Buffer for the palette data to be written</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="2" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-33461"></A>GRreqlutil</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-29969"></A>[intn]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-15947"></A>(mgrltil)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15949"></A>pal_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15951"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15953"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-15955"></A>Palette identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15959"></A>interlace_mode</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15961"></A>intn</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15963"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-33481"></A>Interlace mode for the next palette read operation</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="2" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-15967"></A>GRreadlut</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-29970"></A>[intn]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-15968"></A>(mgrdlut/</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-22884"></A>mgrclut)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15970"></A>pal_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15972"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15974"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-15976"></A>Palette identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15980"></A>pal_data</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-15982"></A>VOIDP</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-22887"></A>&lt;valid numeric data type&gt;(*)/character*(*)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-15986"></A>Buffer for the palette data to be read</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Example">
<A NAME="50593878_pgfId-12091"></A><DIV>
<IMG SRC="UG_html-51.gif" ALT="">
</DIV>
Writing a Palette.</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-49985"></A>This example illustrates the use of the routines <EM CLASS="FunctionName">
GRgetlutid/mggltid</EM>
 and <EM CLASS="FunctionName">
GRwritelut/mgwclut</EM>
 to attach a palette to a raster image and write data to it.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-49989"></A>In this example, the program creates an image named &quot;Image with Palette&quot; in the file &quot;Image_with_Palette.hdf&quot;. A palette is then attached to the image and data is written to it.</P>
</DIV>
</DIV>
</DIV>
</DIV>
<DIV>
<H4 CLASS="Code-C-Title">
<A NAME="50593878_pgfId-15593"></A><DIV>
<IMG SRC="UG_html-53.gif" ALT="">
</DIV>
C:		</H4>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-50129"></A>#include &quot;hdf.h&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54434"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54435"></A>#define  FILE_NAME         &quot;Image_with_Palette.hdf&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54436"></A>#define  NEW_IMAGE_NAME    &quot;Image with Palette&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54437"></A>#define  N_COMPS_IMG       2       /* number of image components */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54438"></A>#define  X_LENGTH          5</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54439"></A>#define  Y_LENGTH          5</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54440"></A>#define  N_ENTRIES         256     /* number of entries in the palette */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54441"></A>#define  N_COMPS_PAL       3       /* number of palette’s components */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54442"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54443"></A>main( )</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54444"></A>{</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54445"></A>   /************************* Variable declaration **************************/</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54446"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54447"></A>   intn  status,         /* status for functions returning an intn */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54448"></A>         i, j;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54449"></A>   int32 file_id, gr_id, ri_id, pal_id, </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54450"></A>         interlace_mode, </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54451"></A>         start[2],     /* holds where to start to write for each dimension  */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54452"></A>         edges[2],     /* holds how long to write for each dimension */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54453"></A>         dim_sizes[2];  /* sizes of the two dimensions of the image array   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54454"></A>   uint8 image_buf[Y_LENGTH][X_LENGTH][N_COMPS_IMG]; /* data of first image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54455"></A>   uint8 palette_buf[N_ENTRIES][N_COMPS_PAL];</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54456"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54457"></A>   /********************** End of variable declaration **********************/</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54458"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54459"></A>   /* </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54460"></A>   * Open the HDF file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54461"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54462"></A>   file_id = Hopen (FILE_NAME, DFACC_CREATE, 0);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54463"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54464"></A>   /* </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54465"></A>   * Initialize the GR interface.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54466"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54467"></A>   gr_id = GRstart (file_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54468"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54469"></A>   /* </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54470"></A>   * Define the dimensions and interlace mode of the image. </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54471"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54472"></A>   dim_sizes[0] = X_LENGTH;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54473"></A>   dim_sizes[1] = Y_LENGTH;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54474"></A>   interlace_mode = MFGR_INTERLACE_PIXEL;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54475"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54476"></A>   /* </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54477"></A>   * Create the image named NEW_IMAGE_NAME.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54478"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54479"></A>   ri_id = GRcreate (gr_id, NEW_IMAGE_NAME, N_COMPS_IMG, DFNT_UINT8, </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54480"></A>                     interlace_mode, dim_sizes);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54481"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54482"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54483"></A>   * Fill the image data buffer with values.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54484"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54485"></A>   for (i = 0; i &lt; Y_LENGTH; i++)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54486"></A>   {</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54487"></A>      for (j = 0; j &lt; X_LENGTH; j++)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54488"></A>      {</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54489"></A>         image_buf[i][j][0] = (i + j) + 1;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54490"></A>         image_buf[i][j][1] = (i + j) + 2;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54491"></A>      }</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54492"></A>    }</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54493"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54494"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54495"></A>   * Define the size of the data to be written, i.e., start from the origin</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54496"></A>   * and go as long as the length of each dimension.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54497"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54498"></A>   start[0] = start[1] = 0;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54499"></A>   edges[0] = X_LENGTH;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54500"></A>   edges[1] = Y_LENGTH;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54501"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54502"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54503"></A>   * Write the data in the buffer into the image array.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54504"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54505"></A>   status = GRwriteimage (ri_id, start, NULL, edges, (VOIDP)image_buf);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54506"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54507"></A>   /* </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54508"></A>   * Initialize the palette to grayscale. </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54509"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54510"></A>   for (i = 0; i &lt; N_ENTRIES; i++) {</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54511"></A>      palette_buf[i][0] = i;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54512"></A>      palette_buf[i][1] = i;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54513"></A>      palette_buf[i][2] = i;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54514"></A>   }</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54515"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54516"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54517"></A>   * Define palette interlace mode.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54518"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54519"></A>   interlace_mode = MFGR_INTERLACE_PIXEL;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54520"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54521"></A>   /* </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54522"></A>   * Get the identifier of the palette attached to the image NEW_IMAGE_NAME.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54523"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54524"></A>   pal_id = GRgetlutid (ri_id, 0);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54525"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54526"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54527"></A>   * Write data to the palette.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54528"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54529"></A>   status = GRwritelut (pal_id, N_COMPS_PAL, DFNT_UINT8, interlace_mode,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54530"></A>                        N_ENTRIES, (VOIDP)palette_buf);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54531"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54532"></A>   /* </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54533"></A>   * Terminate access to the image and to the GR interface, and </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54534"></A>   * close the HDF file. </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54535"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54536"></A>   status = GRendaccess (ri_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54537"></A>   status = GRend (gr_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54538"></A>   status = Hclose (file_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54539"></A>}</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54540"></A>&nbsp;</P>
</DIV>
<DIV>
<H4 CLASS="Code-F-Title">
<A NAME="50593878_pgfId-50257"></A><DIV>
<IMG SRC="UG_html-53.gif" ALT="">
</DIV>
FORTRAN:	</H4>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-50420"></A>      program  write_palette</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54544"></A>      implicit none</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54545"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54546"></A>C     Parameter declaration</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54547"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54548"></A>      character*22 FILE_NAME</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54549"></A>      character*18 NEW_IMAGE_NAME</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54550"></A>      integer      X_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54551"></A>      integer      Y_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54552"></A>      integer      N_ENTRIES</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54553"></A>      integer      N_COMPS_IMG</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54554"></A>      integer      N_COMPS_PAL</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54555"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54556"></A>      parameter (FILE_NAME       = ’Image_with_Palette.hdf’,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54557"></A>     +           NEW_IMAGE_NAME  = ’Image with Palette’,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54558"></A>     +           X_LENGTH        = 5,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54559"></A>     +           Y_LENGTH        = 5,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54560"></A>     +           N_ENTRIES       = 256,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54561"></A>     +           N_COMPS_IMG     = 2,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54562"></A>     +           N_COMPS_PAL     = 3)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54563"></A>      integer DFACC_CREATE, DFNT_CHAR8, DFNT_UINT8, MFGR_INTERLACE_PIXEL</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54564"></A>      parameter (DFACC_CREATE = 4,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54565"></A>     +           DFNT_CHAR8   = 4,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54566"></A>     +           DFNT_UINT8   = 21,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54567"></A>     +           MFGR_INTERLACE_PIXEL = 0)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54568"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54569"></A>C     Function declaration</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54570"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54571"></A>      integer hopen, hclose</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54572"></A>      integer mgstart, mgcreat, mgwcimg, mggltid, mgwclut, </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54573"></A>     +        mgendac, mgend </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54574"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54575"></A>C**** Variable declaration *******************************************</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54576"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54577"></A>      integer    file_id, gr_id, ri_id, pal_id</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54578"></A>      integer    interlace_mode</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54579"></A>      integer    start(2), stride(2), edges(2), dim_sizes(2)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54580"></A>      integer    status</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54581"></A>      integer    i, j</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54582"></A>      character  image_buf(N_COMPS_IMG, X_LENGTH, Y_LENGTH) </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54583"></A>      character  palette_buf(N_COMPS_PAL, N_ENTRIES)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54584"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54585"></A>C**** End of variable declaration ************************************</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54586"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54587"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54588"></A>C     Create and open the file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54589"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54590"></A>      file_id = hopen(FILE_NAME, DFACC_CREATE, 0)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54591"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54592"></A>C     Initialize the GR interface.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54593"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54594"></A>      gr_id = mgstart(file_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54595"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54596"></A>C     Define interlace mode and dimensions of the image.  </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54597"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54598"></A>      interlace_mode = MFGR_INTERLACE_PIXEL</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54599"></A>      dim_sizes(1) = X_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54600"></A>      dim_sizes(2) = Y_lENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54601"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54602"></A>C     Create the raster image array. </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54603"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54604"></A>      ri_id = mgcreat(gr_id, NEW_IMAGE_NAME, N_COMPS_IMG, DFNT_CHAR8,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54605"></A>     +                interlace_mode, dim_sizes)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54606"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54607"></A>C     Fill the image data buffer with values. </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54608"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54609"></A>      do 20 i = 1, Y_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54610"></A>         do 10 j = 1, X_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54611"></A>               image_buf(1,j,i) = char(i + j - 1 )</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54612"></A>               image_buf(2,j,i) = char(i + j) </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54613"></A>10       continue</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54614"></A>20    continue</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54615"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54616"></A>C     </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54617"></A>C     Define the size of the data to be written, i.e., start from the origin</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54618"></A>C     and go as long as the length of each dimension.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54619"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54620"></A>      start(1) = 0</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54621"></A>      start(2) = 0</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54622"></A>      edges(1) = X_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54623"></A>      edges(2) = Y_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54624"></A>      stride(1) = 1</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54625"></A>      stride(2) = 1</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54626"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54627"></A>C     Write the data in the buffer into the image array.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54628"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54629"></A>      status = mgwcimg(ri_id, start, stride, edges, image_buf)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54630"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54631"></A>C     Initilaize the palette buffer to grayscale.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54632"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54633"></A>      do 40 i = 1, N_ENTRIES</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54634"></A>          do 30 j = 1, N_COMPS_PAL</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54635"></A>             palette_buf(j,i) = char(i)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54636"></A>30        continue</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54637"></A>40    continue </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54638"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54639"></A>C     Get the identifier of the palette attached to the image NEW_IMAGE_NAME.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54640"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54641"></A>      pal_id = mggltid(ri_id, 0)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54642"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54643"></A>C     Set palette interlace mode.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54644"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54645"></A>      interlace_mode = MFGR_INTERLACE_PIXEL</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54646"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54647"></A>C     Write data to the palette.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54648"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54649"></A>      status = mgwclut(pal_id, N_COMPS_PAL, DFNT_UINT8, interlace_mode,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54650"></A>     +                 N_ENTRIES, palette_buf)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54651"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54652"></A>C     Terminate access to the raster image and to the GR interface,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54653"></A>C     and close the HDF file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54654"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54655"></A>      status = mgendac(ri_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54656"></A>      status = mgend(gr_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54657"></A>      status = hclose(file_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54658"></A>      end</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54659"></A><A NAME="50593878_marker-50419"></A>&nbsp;</P>
<DIV>
<H6 CLASS="Example">
<A NAME="50593878_pgfId-50425"></A><DIV>
<IMG SRC="UG_html-51.gif" ALT="">
</DIV>
Reading a Palette.</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-55850"></A>This example illustrates the use of the routines <EM CLASS="FunctionName">
GRgetlutinfo/mgglinf</EM>
 and <EM CLASS="FunctionName">
GRreadlut/mgrclut</EM>
 to obtain information about a palette and to read palette data.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-55854"></A>In this example, the program finds and selects the image named &quot;Image with Palette&quot; in the file &quot;Image_with_Palette.hdf&quot;. Then the program obtains information about the palette and reads the palette data.</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="Code-C-Title">
<A NAME="50593878_pgfId-50426"></A><DIV>
<IMG SRC="UG_html-53.gif" ALT="">
</DIV>
C:</H4>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-50511"></A>#include &quot;hdf.h&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54662"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54663"></A>#define  FILE_NAME      &quot;Image_with_Palette.hdf&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54664"></A>#define  IMAGE_NAME     &quot;Image with Palette&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54665"></A>#define  N_ENTRIES      256     /* number of elements of each color */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54666"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54667"></A>main( )</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54668"></A>{</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54669"></A>   /************************* Variable declaration **************************/</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54670"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54671"></A>   intn  status,         /* status for functions returning an intn */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54672"></A>         i, j;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54673"></A>   int32 file_id, gr_id, ri_id, pal_id, ri_index;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54674"></A>   int32 data_type, n_comps, n_entries, interlace_mode; </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54675"></A>   uint8 palette_data[N_ENTRIES][3];        /* static because of fixed size */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54676"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54677"></A>   /************************* Variable declaration **************************/</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54678"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54679"></A>   /* </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54680"></A>   * Open the file. </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54681"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54682"></A>   file_id = Hopen (FILE_NAME, DFACC_READ, 0);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54683"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54684"></A>   /* </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54685"></A>   * Initiate the GR interface. </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54686"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54687"></A>   gr_id = GRstart (file_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54688"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54689"></A>   /* </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54690"></A>   * Get the index of the image IMAGR_NAME.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54691"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54692"></A>   ri_index = GRnametoindex (gr_id, IMAGE_NAME);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54693"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54694"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54695"></A>   * Get image identifier.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54696"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54697"></A>   ri_id = GRselect (gr_id, ri_index);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54698"></A> &nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54699"></A>   /* </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54700"></A>   * Get the identifier of the palette attached to the image. </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54701"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54702"></A>   pal_id = GRgetlutid (ri_id, ri_index);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54703"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54704"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54705"></A>   * Obtain and display information about the palette.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54706"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54707"></A>   status = GRgetlutinfo (pal_id, &amp;n_comps, &amp;data_type, &amp;interlace_mode, </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54708"></A>                          &amp;n_entries);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54709"></A>   printf (&quot;Palette: %d components; %d entries\n&quot;, n_comps, n_entries); </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54710"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54711"></A>   /* </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54712"></A>   * Read the palette data. </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54713"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54714"></A>   status = GRreadlut (pal_id, (VOIDP)palette_data);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54715"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54716"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54717"></A>   * Display the palette data.  Recall that HDF supports only 256 colors.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54718"></A>   * Each color is defined by its 3 components. Therefore, </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54719"></A>   * verifying the value of n_entries and n_comps is not necessary and </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54720"></A>   * the buffer to hold the palette data can be static.  However, </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54721"></A>   * if more values or colors are added to the model, these parameters </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54722"></A>   * must be checked to allocate sufficient space when reading a palette.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54723"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54724"></A>   printf (&quot;  Palette Data: \n&quot;);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54725"></A>   for (i=0; i&lt; n_entries; i++)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54726"></A>   {</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54727"></A>      for (j = 0; j &lt; n_comps; j++)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54728"></A>         printf (&quot;%i &quot;, palette_data[i][j]);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54729"></A>      printf (&quot;\n&quot;);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54730"></A>   }</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54731"></A>   printf (&quot;\n&quot;);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54732"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54733"></A>   /* </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54734"></A>   * Terminate access to the image and to the GR interface, and </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54735"></A>   * close the HDF file. </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54736"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54737"></A>   status = GRendaccess (ri_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54738"></A>   status = GRend (gr_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54739"></A>   status = Hclose (file_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54740"></A>}</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54741"></A>&nbsp;</P>
</DIV>
<DIV>
<H4 CLASS="Code-F-Title">
<A NAME="50593878_pgfId-50520"></A><DIV>
<IMG SRC="UG_html-53.gif" ALT="">
</DIV>
FORTRAN:</H4>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-50609"></A>      program  read_palette</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54745"></A>      implicit none</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54746"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54747"></A>C     Parameter declaration</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54748"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54749"></A>      character*22 FILE_NAME</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54750"></A>      character*18 IMAGE_NAME</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54751"></A>      integer      N_ENTRIES</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54752"></A>      integer      N_COMPS_PAL</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54753"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54754"></A>      parameter (FILE_NAME   = ’Image_with_Palette.hdf’,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54755"></A>     +           IMAGE_NAME  = ’Image with Palette’,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54756"></A>     +           N_COMPS_PAL = 3,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54757"></A>     +           N_ENTRIES   = 256)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54758"></A>      integer DFACC_READ, DFNT_CHAR8, DFNT_UINT8, MFGR_INTERLACE_PIXEL</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54759"></A>      parameter (DFACC_READ  = 1,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54760"></A>     +           DFNT_CHAR8  = 4,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54761"></A>     +           DFNT_UINT8  = 21,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54762"></A>     +           MFGR_INTERLACE_PIXEL = 0)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54763"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54764"></A>C     Function declaration</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54765"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54766"></A>      integer hopen, hclose</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54767"></A>      integer mgstart, mgn2ndx, mgselct, mggltid, mgglinf, </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54768"></A>     +        mgrclut, mgendac, mgend </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54769"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54770"></A>C**** Variable declaration *******************************************</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54771"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54772"></A>      integer    file_id, gr_id, ri_id, ri_index, pal_id, pal_index</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54773"></A>      integer    interlace_mode</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54774"></A>      integer    data_type, n_comps, n_entries_out</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54775"></A>      integer    status</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54776"></A>      integer    i, j</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54777"></A>      character  palette_data(N_COMPS_PAL, N_ENTRIES)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54778"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54779"></A>C**** End of variable declaration ************************************</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54780"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54781"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54782"></A>C     Open the file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54783"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54784"></A>      file_id = hopen(FILE_NAME, DFACC_READ, 0)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54785"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54786"></A>C     Initialize the GR interface.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54787"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54788"></A>      gr_id = mgstart(file_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54789"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54790"></A>C     Get the index of the image IMAGE_NAME.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54791"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54792"></A>      ri_index = mgn2ndx(gr_id, IMAGE_NAME)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54793"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54794"></A>C     Get the image identifier.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54795"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54796"></A>      ri_id = mgselct(gr_id, 0)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54797"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54798"></A>C     Get the identifier of the palette attached to the image.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54799"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54800"></A>      pal_index = 0</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54801"></A>      pal_id = mggltid(ri_id, pal_index)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54802"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54803"></A>C     Obtain information about the palette.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54804"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54805"></A>      status = mgglinf(pal_id, n_comps, data_type, interlace_mode,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54806"></A>     +                 n_entries_out)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54807"></A>      write(*,*) ’ Palette: ’, n_comps, ’ components;  ’, </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54808"></A>     +           n_entries_out, ’ entries’</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54809"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54810"></A>C     Read the palette.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54811"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54812"></A>      status = mgrclut(pal_id, palette_data)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54813"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54814"></A>C     Display the palette data.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54815"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54816"></A>      write(*,*) &quot;Palette data&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54817"></A>      do 10 i = 1, n_entries_out</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54818"></A>         write(*,*) (ichar(palette_data(j,i)), j = 1, n_comps)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54819"></A>10    continue  </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54820"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54821"></A>C     Terminate access to the raster image and to the GR interface,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54822"></A>C     and close the HDF file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54823"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54824"></A>      status = mgendac(ri_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54825"></A>      status = mgend(gr_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54826"></A>      status = hclose(file_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54827"></A>      end</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-54828"></A>&nbsp;</P>
<DIV>
<H5 CLASS="Heading2">
<A NAME="50593878_pgfId-55105"></A>	8.12	Ch<A NAME="50593878_marker-55104"></A>unked Raster Images<DIV>
<IMG SRC="UG_html-50.gif" ALT="">
</DIV>
</H5>
<P CLASS="Body">
<A NAME="50593878_pgfId-55106"></A>The GR interface also supports chunking in a manner similar to that of the SD interface. There is one restriction on a raster image: it must be created with MFGR<A NAME="50593878_marker-55107"></A>_INTERLACE_PIXEL (or <EM CLASS="DefName">
0</EM>
) in the call to <EM CLASS="FunctionName">
GRcreate</EM>
. We refer the reader to Section 3.11 of <A HREF="UG_html-3.htm#50593873_13938" CLASS="XRef">Scientific Data Sets (SD API)</A>, and to <A HREF="UG_html-14.htm#50593884_34005" CLASS="XRef">HDF Performance Issues</A>, for discussions of chunking concepts and performance related topics. The GR interface provides three routines, <EM CLASS="FunctionName">
GRsetchunk</EM>
, <EM CLASS="FunctionName">
GRsetchunkcache</EM>
, and <EM CLASS="FunctionName">
GRgetchunkinfo</EM>
, to create and maintain chunked raster images. The generic functions for reading and writing GR images, <EM CLASS="FunctionName">
GRwriteimage</EM>
 and <EM CLASS="FunctionName">
GRreadimage</EM>
, will write and read chunked raster images as well. However, the GR interface provides special write and read routines, <EM CLASS="FunctionName">
GRwritechunk</EM>
 and <EM CLASS="FunctionName">
GRreadchunk,</EM>
 which are similar to <EM CLASS="FunctionName">
SDwritechunk</EM>
 and <EM CLASS="FunctionName">
SDreadchunk</EM>
. Compared to <EM CLASS="FunctionName">
GRwriteimage</EM>
 and <EM CLASS="FunctionName">
GRreadimage</EM>
, <EM CLASS="FunctionName">
GRwritechunk</EM>
 and <EM CLASS="FunctionName">
GRreadchunk</EM>
 are low-overhead but are only sutable for writing or reading complete chunks.</P>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-61063"></A>	8.12.1	Difference between a Chunked Raster Image and a Chunked SDS</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-61064"></A>Chunks of scientific datasets (SDSs) have the same dimensionality as the SDS itself and the chunks can divide the SDS along any dimension.  While raster images under the GR interface are actually 3-dimensional arrays, 2 dimensions define the image while the third dimension (the stack of 2-dimensional image planes) provides the composite definition of the color at each pixel of the 2-dimensional image. Chunking can be applied only across the 2-dimensions of the image; chunking cannot divide the array across the third dimension.  In other words, all of the elements of the raster image that define a single pixel must remain together in the same chunk. </P>
<DIV>
<H6 CLASS="Figure">
<A NAME="50593878_pgfId-61094"></A><DIV>
<IMG SRC="UG_html-51.gif" ALT="">
</DIV>
FIGURE 8b	Chunks in a GR raster image dataset</H6>
<DIV>
<IMG SRC="UG_html-54.gif" ALT="">
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-61066"></A>	8.12.2	<A NAME="50593878_24765"></A>Making a Raster Image a Chunked Raster Image: GRsetchunk</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-38105"></A><EM CLASS="FunctionName">
GRsetchunk</EM>
<A NAME="50593878_marker-55894"></A> makes the raster image, identified by the parameter <EM CLASS="VarName">
ri_id</EM>
, a chunked raster image according to the provided chunking and compression information. The syntax of <EM CLASS="FunctionName">
GRsetchunk</EM>
 is as follows:</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-35062"></A><EM CLASS="syntaxLang">
C:</EM>
		status = GRsetchunk(ri_id, c_def, flags);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-35063"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	status = mgschnk(ri_id, dim_length, comp_type, comp_prm)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-38098"></A>The parameters <EM CLASS="VarName">
c_def</EM>
 and <EM CLASS="VarName">
flags</EM>
 in C or the parameters <EM CLASS="VarName">
comp_type</EM>
 and <EM CLASS="VarName">
comp_prm</EM>
 in FORTRAN-77 provide the chunking and compression information and are discussed below.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-35064"></A><EM CLASS="Definition">
In C:</EM>
</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-82323"></A>The parameter <EM CLASS="VarName">
c_def</EM>
 is a union of type <EM CLASS="DefName">
HDF_CHUNK_DEF</EM>
, which is defined as follows:</P>
<UL>
<LI CLASS="codebodyUG">
<A NAME="50593878_pgfId-82324"></A>&nbsp;</LI>
<LI CLASS="codebodyUG">
<A NAME="50593878_pgfId-82325"></A>typedef union hdf_chunk_def_u</LI>
<LI CLASS="codebodyUG">
<A NAME="50593878_pgfId-35068"></A>    {</LI>
<LI CLASS="codebodyUG">
<A NAME="50593878_pgfId-35069"></A>     int32 chunk_lengths[2];  /* chunk lengths along each dim */</LI>
<LI CLASS="codebodyUG">
<A NAME="50593878_pgfId-35070"></A>     </LI>
<LI CLASS="codebodyUG">
<A NAME="50593878_pgfId-35071"></A>     struct</LI>
<LI CLASS="codebodyUG">
<A NAME="50593878_pgfId-35072"></A>          {</LI>
<LI CLASS="codebodyUG">
<A NAME="50593878_pgfId-35073"></A>           int32 chunk_lengths[2];</LI>
<LI CLASS="codebodyUG">
<A NAME="50593878_pgfId-35074"></A>           int32 comp_type;              /* compression type */</LI>
<LI CLASS="codebodyUG">
<A NAME="50593878_pgfId-35075"></A>           struct comp_info cinfo;</LI>
<LI CLASS="codebodyUG">
<A NAME="50593878_pgfId-35076"></A>          } comp;</LI>
<LI CLASS="codebodyUG">
<A NAME="50593878_pgfId-35077"></A>&nbsp;</LI>
<LI CLASS="codebodyUG">
<A NAME="50593878_pgfId-35078"></A>     struct </LI>
<LI CLASS="codebodyUG">
<A NAME="50593878_pgfId-35079"></A>          {     </LI>
<LI CLASS="codebodyUG">
<A NAME="50593878_pgfId-35080"></A>          /* is not used in GR interface */</LI>
<LI CLASS="codebodyUG">
<A NAME="50593878_pgfId-35081"></A>          } nbit;</LI>
<LI CLASS="codebodyUG">
<A NAME="50593878_pgfId-35082"></A>     } HDF_CHUNK_DEF</LI>
</UL>
<P CLASS="Body">
<A NAME="50593878_pgfId-35083"></A>Valid values of the parameter <EM CLASS="VarName">
flags</EM>
 are <EM CLASS="DefName">
HDF_CHUNK</EM>
 for chunked and uncompressed data and (<EM CLASS="DefName">
HDF_CHUNK | HDF_COMP</EM>
) for chunked and compressed data. Data can be compressed using run-length encoding (RLE), Skipping Huffman, GZIP, or Szip compression algorithms.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-35084"></A>If the parameter <EM CLASS="VarName">
flags</EM>
 has a value of <EM CLASS="DefName">
HDF_CHUNK</EM>
, the chunk dimensions must be specified in the field <EM CLASS="Code">
c_def.chunk_lengths[]</EM>
. If the parameter <EM CLASS="VarName">
flags</EM>
 has a value of (<EM CLASS="DefName">
HDF_CHUNK | HDF_COMP</EM>
), the chunk dimensions must be specified in the field <EM CLASS="Code">
c_def.comp.chunk_lengths[]</EM>
 and the compression type in the field <EM CLASS="Code">
c_def.comp.comp_type</EM>
<EM CLASS="DefName">
. </EM>
Valid values of compression type values are:</P>
<P CLASS="List10pt">
<A NAME="50593878_pgfId-95658"></A><EM CLASS="DefName">
COMP_CODE_NONE</EM>
 (or <EM CLASS="DefName">
0</EM>
) for uncompressed data</P>
<P CLASS="List10pt">
<A NAME="50593878_pgfId-95661"></A><EM CLASS="DefName">
COMP_CODE_RLE</EM>
 (or <EM CLASS="DefName">
1</EM>
) for RLE compression</P>
<P CLASS="List10pt">
<A NAME="50593878_pgfId-95664"></A><EM CLASS="DefName">
COMP_CODE_SKPHUFF</EM>
 (or <EM CLASS="DefName">
3</EM>
) for Skipping Huffman compression</P>
<P CLASS="List10pt">
<A NAME="50593878_pgfId-95667"></A><EM CLASS="DefName">
COMP_CODE_DEFLATE</EM>
 (or <EM CLASS="DefName">
4</EM>
) for GZIP compression</P>
<P CLASS="List10pt">
<A NAME="50593878_pgfId-95670"></A><EM CLASS="DefName">
COMP_CODE_SZIP</EM>
 (or <EM CLASS="DefName">
5</EM>
) for Szip compression</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-82473"></A>For Skipping Huffman, GZIP, and Szip compression methods, parameters are passed in corresponding fields of the structure <EM CLASS="VarName">
cinfo</EM>
. Specify skipping size for Skipping Huffman compression in the field <EM CLASS="Code">
c_def.comp.cinfo.skphuff.skp_size</EM>
; this value cannot be less than 1. Specify deflate level for GZIP compression in the field <EM CLASS="Code">
c_def.comp.cinfo.deflate_level</EM>
. Valid values of deflate levels are integers from 0 to 9 inclusive.  Specify the Szip options mask and the number of pixels per block in a chunked and Szip-compressed dataset in the fields <EM CLASS="Code">
c_info.szip.options_mask</EM>
 and <EM CLASS="Code">
c_info.szip.pixels_per_block</EM>
, respectively<EM CLASS="Code">
.</EM>
</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-82486"></A>Refer to the discussion of <EM CLASS="FunctionName">
SDsetcompress </EM>
routine in <A HREF="UG_html-3.htm#50593873_22986" CLASS="XRef">Compressing SDS Data: SDsetcompress</A> for the definition of the structure <EM CLASS="VarName">
comp_info</EM>
.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-82532"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-35090"></A><EM CLASS="Definition">
In FORTRAN-77:</EM>
</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-82528"></A>Chunk dimensions are specified in the array <EM CLASS="VarName">
dim_length</EM>
 and the compression type in the parameter <EM CLASS="VarName">
comp_type</EM>
. Valid compression types and their values are defined in the <EM CLASS="Code">
hdf.inc</EM>
 file and are listed below:</P>
<P CLASS="List10pt">
<A NAME="50593878_pgfId-35092"></A><EM CLASS="DefName">
COMP_CODE_NONE</EM>
 (or <EM CLASS="DefName">
0</EM>
) for uncompressed data</P>
<P CLASS="List10pt">
<A NAME="50593878_pgfId-35093"></A><EM CLASS="DefName">
COMP_CODE_RLE</EM>
 (or <EM CLASS="DefName">
1</EM>
) for RLE compression</P>
<P CLASS="List10pt">
<A NAME="50593878_pgfId-35094"></A><EM CLASS="DefName">
COMP_CODE_SKPHUFF</EM>
 (or <EM CLASS="DefName">
3</EM>
) for Skipping Huffman compression</P>
<P CLASS="List10pt">
<A NAME="50593878_pgfId-35095"></A><EM CLASS="DefName">
COMP_CODE_DEFLATE</EM>
 (or <EM CLASS="DefName">
4</EM>
) for GZIP compression</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-55144"></A>The parameter <EM CLASS="VarName">
comp_prm</EM>
 specifies the compression parameters for the Skipping Huffman and GZIP compression methods. It contains only one element which is set to the skipping size for Skipping Huffman compression or the deflate level for GZIP compression.  Currently, Szip compression is not yet supported by Fortran GR interface.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-55149"></A><EM CLASS="FunctionName">
GRsetchunk</EM>
 returns <EM CLASS="DefName">
SUCCEED</EM>
 (or <EM CLASS="DefName">
0</EM>
) if successful and <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
) otherwise. The <EM CLASS="FunctionName">
GRsetchunk</EM>
 parameters are discussed further in <A HREF="UG_html-8.htm#50593878_37735" CLASS="XRef">GRsetchunk, GRgetchunkinfo, GRsetchunkcache, GRwritechunk, and GRreadchunk Parameter Lists</A></P>
</DIV>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-62109"></A>	8.12.3	<A NAME="50593878_68057"></A>Writing a Chunked Raster Image: GRwritechunk</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-63025"></A><EM CLASS="FunctionName">
GRwritechunk</EM>
<A NAME="50593878_marker-63024"></A> is used to write a chunk of a chunked raster image. The syntax of the <EM CLASS="FunctionName">
GRwritechunk</EM>
 routine is as follows: </P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-63026"></A><EM CLASS="syntaxLang">
C:</EM>
		status = GRwritechunk(ri_id, &amp;origin, &amp;datap);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-63027"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	status = mgwchnk(ri_id, origin, datap)</P>
<P CLASS="syntax">
<A NAME="50593878_pgfId-63257"></A>		status = mgwcchnk(ri_id, origin, datap)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-63105"></A><EM CLASS="FunctionName">
GRwritechunk</EM>
 writes the entire chunk of data stored in the buffer <EM CLASS="VarName">
datap</EM>
 to the chunked raster image identified by the parameter <EM CLASS="VarName">
ri_id</EM>
. Writing starts at the location specified by the parameter <EM CLASS="VarName">
origin</EM>
. This function has less overhead than <EM CLASS="FunctionName">
GRwriteimage</EM>
 and should be used whenever an entire chunk of data is to be written.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-63158"></A>The raster image must be stored in pixel-interlace mode.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-63106"></A>The parameter <EM CLASS="VarName">
origin</EM>
 is a two-dimensional array which specifies the coordinates of the chunk according to the chunk position in the overall chunk array. </P>
<P CLASS="Body">
<A NAME="50593878_pgfId-63094"></A>The <EM CLASS="VarName">
datap </EM>
buffer contains the chunk data.  The data must be organized in pixel-interlace mode.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-63279"></A>Note that the FORTRAN-77 version of <EM CLASS="FunctionName">
GRwritechunk</EM>
 has two routines; <EM CLASS="FunctionName">
mgwchnk</EM>
 writes buffered numeric data and <EM CLASS="FunctionName">
mgwcchnk</EM>
 writes buffered character data.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-63035"></A><EM CLASS="FunctionName">
GRwritechunk</EM>
 returns <EM CLASS="DefName">
SUCCEED</EM>
 (or <EM CLASS="DefName">
0</EM>
) if successful and <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
) otherwise. The <EM CLASS="FunctionName">
GRwritechunk</EM>
 parameters are discussed further in <A HREF="UG_html-8.htm#50593878_37735" CLASS="XRef">Table 8L</A>.</P>
<DIV>
<H6 CLASS="Example">
<A NAME="50593878_pgfId-65591"></A><DIV>
<IMG SRC="UG_html-51.gif" ALT="">
</DIV>
<A NAME="50593878_marker-65590"></A>Creating and Writing a Chunked Raster Image</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-65592"></A>This example illustrates the use of the routines <EM CLASS="FunctionName">
Hopen</EM>
/<EM CLASS="FunctionName">
hopen</EM>
, <EM CLASS="FunctionName">
GRstart</EM>
/<EM CLASS="FunctionName">
mgstart</EM>
, <EM CLASS="FunctionName">
GRcreate</EM>
/<EM CLASS="FunctionName">
mgcreat</EM>
, <EM CLASS="FunctionName">
GRwritechunk</EM>
/<EM CLASS="FunctionName">
mgwchnk</EM>
, <EM CLASS="FunctionName">
GRendaccess</EM>
/<EM CLASS="FunctionName">
mgendac</EM>
, <EM CLASS="FunctionName">
GRend</EM>
/<EM CLASS="FunctionName">
mgend</EM>
, and <EM CLASS="FunctionName">
Hclose</EM>
/<EM CLASS="FunctionName">
hclose</EM>
 to create an HDF file and store a raster image in it.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-65593"></A>In this example, the program creates an image of 6 rows by 10 columns in C and 10 rows by 6 columns in FORTRAN. The image is set up to be chunked with a chunk size of 3x2 in C and 2x3 in FORTRAN and compressed with the GZIP method. Three chunks are then written to the image. See <A HREF="UG_html-8.htm#50593878_72890" CLASS="XRef">Figure 8c</A> through <A HREF="UG_html-8.htm#50593878_33065" CLASS="XRef">Figure 8d</A> for illustrations.</P>
<DIV>
<H6 CLASS="Figure">
<A NAME="50593878_pgfId-65714"></A><DIV>
<IMG SRC="UG_html-51.gif" ALT="">
</DIV>
FIGURE 8c	<A NAME="50593878_72890"></A>Chunked GR image as written by C example </H6>
<DIV>
<IMG SRC="UG_html-55.gif" ALT="">
</DIV>
</DIV>
<DIV>
<H6 CLASS="Figure">
<A NAME="50593878_pgfId-65829"></A><DIV>
<IMG SRC="UG_html-51.gif" ALT="">
</DIV>
FIGURE 8d	<A NAME="50593878_33065"></A>Chunked GR image as written by FORTRAN example</H6>
<DIV>
<IMG SRC="UG_html-56.gif" ALT="">
</DIV>
</DIV>
</DIV>
</DIV>
</DIV>
</DIV>
<DIV>
<H4 CLASS="Code-C-Title">
<A NAME="50593878_pgfId-65831"></A><DIV>
<IMG SRC="UG_html-53.gif" ALT="">
</DIV>
C:</H4>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127183"></A>#include &quot;hdf.h&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127184"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127185"></A>#define FILE_NAME     “Image_Chunked.hdf”</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127186"></A>#define IMAGE_NAME    “Image with Chunks”</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127187"></A>#define X_LENGTH      10    /* number of rows in the image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127188"></A>#define Y_LENGTH      6     /* number of columns in the image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127189"></A>#define NCOMPS        3     /* number of components in the image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127190"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127191"></A>int main()</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127192"></A>{</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127193"></A>   /************************* Variable declaration **************************/</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127194"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127195"></A>   intn  status;         /* status for functions returning an intn */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127196"></A>   int32 file_id,        /* HDF file identifier */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127197"></A>         gr_id,          /* GR interface identifier */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127198"></A>         ri_id,          /* raster image identifier */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127199"></A>         dims[2],        /* dimension sizes of the image array */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127200"></A>         origin[2],      /* origin position to write each chunk */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127201"></A>         interlace_mode; /* interlace mode of the image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127202"></A>   HDF_CHUNK_DEF chunk_def;     /* Chunk defintion set */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127203"></A>   int32 chunk00[] = {1, 2, 3, 4, 5, 6,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127204"></A>                      7, 8, 9, 10, 11, 12,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127205"></A>                      13, 14, 15, 16, 17, 18 };</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127206"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127207"></A>   int32 chunk01[] = {210, 211, 212, 220, 221, 222,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127208"></A>                      230, 231, 232, 240, 241, 242,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127209"></A>                      250, 251, 252, 260, 261, 262};</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127210"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127211"></A>   int32 chunk14[] = {1010, 1011, 1012, 1020, 1021, 1022,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127212"></A>                      1030, 1031, 1032, 1040, 1041, 1042,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127213"></A>                      1050, 1051, 1052, 1060, 1061, 1062};</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127214"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127215"></A>   /********************** End of variable declaration **********************/</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127216"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127217"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127218"></A>   * Create and open the file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127219"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127220"></A>   file_id = Hopen (FILE_NAME, DFACC_CREATE, 0);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127221"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127222"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127223"></A>   * Initialize the GR interface.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127224"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127225"></A>   gr_id = GRstart (file_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127226"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127227"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127228"></A>   * Set dimensions of the image.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127229"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127230"></A>   dims[0] = Y_LENGTH;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127231"></A>   dims[1] = X_LENGTH;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127232"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127233"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127234"></A>   * Create the raster image array.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127235"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127236"></A>   ri_id = GRcreate (gr_id, IMAGE_NAME, NCOMPS, DFNT_INT32,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127237"></A>                     MFGR_INTERLACE_PIXEL, dims);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127238"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127239"></A>   * Define chunked image.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127240"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127241"></A>   chunk_def.comp.comp_type = COMP_CODE_DEFLATE;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127242"></A>   chunk_def.comp.cinfo.deflate.level = 6;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127243"></A>   chunk_def.comp.chunk_lengths[0] = 3;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127244"></A>   chunk_def.comp.chunk_lengths[1] = 2;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127245"></A>   status = GRsetchunk (ri_id, chunk_def, HDF_CHUNK | HDF_COMP);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127246"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127247"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127248"></A>   * Write first chunk(0,0).</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127249"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127250"></A>   origin[0] = 0;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127251"></A>   origin[1] = 0;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127252"></A>   status = GRwritechunk (ri_id, origin, (VOIDP)chunk00);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127253"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127254"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127255"></A>   * Write second chunk(0,1).</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127256"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127257"></A>   origin[0] = 0;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127258"></A>   origin[1] = 1;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127259"></A>   status = GRwritechunk (ri_id, origin, (VOIDP)chunk01);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127260"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127261"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127262"></A>   * Write third chunk(1,4).</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127263"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127264"></A>   origin[0] = 1;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127265"></A>   origin[1] = 4;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127266"></A>   status = GRwritechunk (ri_id, origin, (VOIDP)chunk14);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127267"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127268"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127269"></A>   * Terminate access to the raster image and to the GR interface and,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127270"></A>   * close the HDF file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127271"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127272"></A>   status = GRendaccess (ri_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127273"></A>   status = GRend (gr_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127274"></A>   status = Hclose (file_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127275"></A>   return 0;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127276"></A>}</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-65933"></A>&nbsp;</P>
</DIV>
<DIV>
<H4 CLASS="Code-F-Title">
<A NAME="50593878_pgfId-65934"></A><DIV>
<IMG SRC="UG_html-53.gif" ALT="">
</DIV>
FORTRAN:</H4>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-65937"></A>      program gr_chunking_example</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66693"></A>      implicit none</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66694"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66695"></A>C     Parameter declaraction</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66696"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66697"></A>      character*14 FILE_NAME</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66698"></A>      character*14 DATASET_NAME</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66699"></A>      parameter (FILE_NAME = ’gr_chunked.hdf’,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66700"></A>     .           DATASET_NAME = ’gzip_comp_data’)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66701"></A>      integer   NCOMP, MFGR_INTERLACE_PIXEL</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66702"></A>      parameter(NCOMP = 3, MFGR_INTERLACE_PIXEL = 0)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66703"></A>      integer DFACC_CREATE, DFACC_READ, DFACC_WRITE</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66704"></A>      parameter (DFACC_CREATE = 4,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66705"></A>     .           DFACC_READ   = 1,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66706"></A>     .           DFACC_WRITE  = 2)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66707"></A>      integer DFNT_INT32</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66708"></A>      parameter (DFNT_INT32   = 24)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66709"></A>      integer X_LENGTH, Y_LENGTH, X_CH_LENGTH, Y_CH_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66710"></A>      parameter (X_LENGTH     = 6,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66711"></A>     .           Y_LENGTH     = 10,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66712"></A>     .           X_CH_LENGTH  = 3,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66713"></A>     .           Y_CH_LENGTH  = 2) </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66714"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66715"></A>C     Compression parameters.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66716"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66717"></A>      integer  COMP_CODE_DEFLATE, DEFLATE_LEVEL</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66718"></A>      parameter( COMP_CODE_DEFLATE = 4, DEFLATE_LEVEL = 6)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66719"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66720"></A>C     Function declaration.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66721"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66722"></A>      integer mgstart, mgcreat, mgendac, mgend</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66723"></A>      integer mgwchnk, mgschnk</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66724"></A>      integer hopen, hclose</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66725"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66726"></A>C**** Variable declaration *************************************************</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66727"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66728"></A>      integer ri_id, gr_id, file_id</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66729"></A>      integer dims(2), start(2)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66730"></A>      integer status, il</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66731"></A>      integer comp_prm(1), comp_type</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66732"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66733"></A>C     Data buffers.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66734"></A>C </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66735"></A>      integer*4 chunk11(NCOMP* X_CH_LENGTH*Y_CH_LENGTH)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66736"></A>      integer*4 chunk21(NCOMP* X_CH_LENGTH*Y_CH_LENGTH)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66737"></A>      integer*4 chunk52(NCOMP* X_CH_LENGTH*Y_CH_LENGTH)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66738"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66739"></A>C     Chunking dimension arrays</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66740"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66741"></A>      integer ch_dims(2)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66742"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66743"></A>C**** End of variable declaration ******************************************</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66744"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66745"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66746"></A>C     Data initialization</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66747"></A>C </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66748"></A>      data  chunk11 / 110, 111, 112, 120, 121, 122,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66749"></A>     .                130, 131, 132, 140, 141, 142,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66750"></A>     .                150, 151, 152, 160, 161, 162</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66751"></A>     .              /, </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66752"></A>     .      chunk21 /</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66753"></A>     .                210, 211, 212, 220, 221, 222,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66754"></A>     .                230, 231, 232, 240, 241, 242,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66755"></A>     .                250, 251, 252, 260, 261, 262</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66756"></A>     .              /,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66757"></A>     .      chunk52 /</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66758"></A>     .                1010, 1011, 1012, 1020, 1021, 1022,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66759"></A>     .                1030, 1031, 1032, 1040, 1041, 1042,</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66760"></A>     .                1050, 1051, 1052, 1060, 1061, 1062</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66761"></A>     .              /</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66762"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66763"></A>C     Define chunk dimensions.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66764"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66765"></A>      ch_dims(1) = Y_CH_LENGTH </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66766"></A>      ch_dims(2) = X_CH_LENGTH </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66767"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66768"></A>C     Create and open the file and initiate GR interface..</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66769"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66770"></A>      file_id = hopen(FILE_NAME, DFACC_CREATE, 0)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66771"></A>      gr_id   = mgstart(file_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66772"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66773"></A>C     Define the number of components and dimensions of the image.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66774"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66775"></A>      il      = MFGR_INTERLACE_PIXEL</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66776"></A>      dims(1) = X_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66777"></A>      dims(2) = Y_LENGTH</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66778"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66779"></A>C     Create GR dataset.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66780"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66781"></A>      ri_id = mgcreat(gr_id, DATASET_NAME, NCOMP, DFNT_INT32, il, dims)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66782"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66783"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66784"></A>C     Define chunked GR dataset using GZIP compression.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66785"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66786"></A>      comp_prm(1) =  DEFLATE_LEVEL</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66787"></A>      comp_type = COMP_CODE_DEFLATE</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66788"></A>      status = mgschnk (ri_id, ch_dims, comp_type, comp_prm)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66789"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66790"></A>C     Define the location of the first chunk and write the data.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66791"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66792"></A>      start(1) = 1 </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66793"></A>      start(2) = 1 </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66794"></A>      status = mgwchnk(ri_id, start, chunk11)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66795"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66796"></A>C     Define the location of the second chunk and write the data.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66797"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66798"></A>      start(1) = 2 </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66799"></A>      start(2) = 1 </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66800"></A>      status = mgwchnk(ri_id, start, chunk21)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66801"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66802"></A>C     Define the location of the third and write the data.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66803"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66804"></A>      start(1) = 5 </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66805"></A>      start(2) = 2 </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66806"></A>      status = mgwchnk(ri_id, start, chunk52)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66807"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66808"></A>C     Terminate access to the array.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66809"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66810"></A>      status = mgendac(ri_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66811"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66812"></A>C     Terminate access to the GR interface.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66813"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66814"></A>      status = mgend(gr_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66815"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66816"></A>C     Close the file.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66817"></A>C</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66818"></A>      status = hclose(file_id)</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66819"></A>      end </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66820"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-66067"></A>&nbsp;</P>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-65587"></A>	8.12.4	<A NAME="50593878_48842"></A>Reading a Chunked Raster Image: GRreadchunk</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-63123"></A><EM CLASS="FunctionName">
GRreadchunk</EM>
<A NAME="50593878_marker-63122"></A> is used to read an entire chunk of data from a chunked raster image. The syntax of the <EM CLASS="FunctionName">
GRreadchunk</EM>
 routine is as follows: </P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-63124"></A><EM CLASS="syntaxLang">
C:</EM>
		status = GRreadchunk(ri_id, &amp;origin, datap);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-63125"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	status = mgrchnk(ri_id, origin, datap)</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-63320"></A>	status = mgrcchnk(ri_id, origin, datap)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-63126"></A><EM CLASS="FunctionName">
GRreadchunk</EM>
 reads the entire chunk of data stored from the chunked raster image identified by the parameter <EM CLASS="VarName">
ri_id </EM>
and stores it in the buffer <EM CLASS="VarName">
datap</EM>
. The chunk to be read is specified by the parameter <EM CLASS="VarName">
origin</EM>
. This function has less overhead than <EM CLASS="FunctionName">
GRreadimage</EM>
 and should be used whenever an entire chunk of data is to be read.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-63153"></A>The raster image must be stored in pixel-interlace mode.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-63127"></A>The parameter <EM CLASS="VarName">
origin</EM>
 is a two-dimensional array which specifies the coordinates of the chunk according to the chunk position in the overall chunk array. </P>
<P CLASS="Body">
<A NAME="50593878_pgfId-63128"></A>The <EM CLASS="VarName">
datap </EM>
buffer contains the chunk data.  The data is organized in pixel-interlace mode.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-63312"></A>Note that the FORTRAN-77 version of <EM CLASS="FunctionName">
GRreadchunk</EM>
 has two routines; <EM CLASS="FunctionName">
mgrchnk</EM>
 reads numeric data and <EM CLASS="FunctionName">
mgrcchnk</EM>
 reads character data to the buffer.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-127331"></A><EM CLASS="FunctionName">
GRreadchunk</EM>
 returns <EM CLASS="DefName">
SUCCEED</EM>
 (or <EM CLASS="DefName">
0</EM>
) if successful and <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
) otherwise. <EM CLASS="FunctionName">
GRreadchunk</EM>
 will return <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
) when an attempt is made to read from a non-chunked image. The <EM CLASS="FunctionName">
GRreadchunk</EM>
 parameters are discussed further in <A HREF="UG_html-8.htm#50593878_37735" CLASS="XRef">Table 8L</A>.</P>
<DIV>
<H6 CLASS="Example">
<A NAME="50593878_pgfId-127572"></A><DIV>
<IMG SRC="UG_html-51.gif" ALT="">
</DIV>
Reading a Chunked Raster Image.</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-127598"></A>This example illustrates the use of the routines <EM CLASS="FunctionName">
GRreadchunk/mgrchnk</EM>
 to read the raster image’s chunked data.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-127625"></A>In this example, the program finds and selects the image named &quot;Image with Chunks&quot; in the file &quot;Image_Chunked.hdf&quot;. Then the program obtains information about the image and reads the image data.  Only C example is available at this time.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H4 CLASS="Code-C-Title">
<A NAME="50593878_pgfId-127353"></A><DIV>
<IMG SRC="UG_html-53.gif" ALT="">
</DIV>
C:</H4>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127356"></A>#include &quot;hdf.h&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127357"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127358"></A>#define  FILE_NAME      &quot;Image_Chunked.hdf&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127359"></A>#define  IMAGE_NAME     &quot;Image with Chunks&quot;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127668"></A>#define X_LENGTH      10    /* number of rows in the image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127669"></A>#define Y_LENGTH      6     /* number of columns in the image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127670"></A>#define NCOMPS        3     /* number of components in the image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127671"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127672"></A>int main()</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127673"></A>{</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127674"></A>   /************************* Variable declaration **************************/</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127675"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127676"></A>   intn  status;         /* status for functions returning an intn */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127677"></A>   int32 file_id,        /* HDF file identifier */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127678"></A>         gr_id,          /* GR interface identifier */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127679"></A>         ri_id,          /* raster image identifier */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127680"></A>         dims[2],        /* dimension sizes of the image array */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127681"></A>         origin[2],      /* origin position to write each chunk */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127732"></A>         interlace_mode; /* interlace mode of the image */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127737"></A>   HDF_CHUNK_DEF chunk_def;     /* Chunk defintion set */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127747"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127748"></A>   /************************* Variable declaration **************************/</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127726"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127716"></A>   /* </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127375"></A>   * Open the file. </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127376"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127377"></A>   file_id = Hopen (FILE_NAME, DFACC_READ, 0);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127378"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127379"></A>   /* </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127380"></A>   * Initiate the GR interface. </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127381"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127382"></A>   gr_id = GRstart (file_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127383"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127384"></A>   /* </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127385"></A>   * Get the index of the image IMAGR_NAME.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127386"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127387"></A>   ri_index = GRnametoindex (gr_id, IMAGE_NAME);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127388"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127389"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127390"></A>   * Get image identifier.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127391"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127392"></A>   ri_id = GRselect (gr_id, ri_index);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127393"></A> &nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127758"></A>   /*</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127759"></A>   * Set dimensions of the image.</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127760"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127761"></A>   dims[0] = X_LENGTH;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127762"></A>   dims[1] = Y_LENGTH;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127763"></A>   start[0] = start[1] = 0;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127764"></A>   edges[0] = dims[0];</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127765"></A>   edges[1] = dims[1];</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127766"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127767"></A>   /* Read the data in the image array. */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127768"></A>   status = GRreadimage (ri_id, start, NULL, edges, (VOIDP)image_data);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127427"></A>&nbsp;</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127428"></A>   /* </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127429"></A>   * Terminate access to the image and to the GR interface, and </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127430"></A>   * close the HDF file. </P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127431"></A>   */</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127432"></A>   status = GRendaccess (ri_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127433"></A>   status = GRend (gr_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127434"></A>   status = Hclose (file_id);</P>
<P CLASS="ExampleCode">
<A NAME="50593878_pgfId-127435"></A>}</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-127341"></A>&nbsp;</P>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-127336"></A>	8.12.5	<A NAME="50593878_33313"></A>Obtaining Information about a Chunked Raster Image: GRgetchunkinfo</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-35098"></A><EM CLASS="FunctionName">
GRgetchunkinfo</EM>
<A NAME="50593878_marker-55893"></A> is used to determine whether a raster image is chunked and how chunking is defined. The syntax of the <EM CLASS="FunctionName">
GRgetchunkinfo</EM>
 routine is as follows: </P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-35100"></A><EM CLASS="syntaxLang">
C:</EM>
		status = GRgetchunkinfo(ri_id, &amp;c_def, &amp;flag);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-35103"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	status = mggichnk(ri_id, dim_length, flag)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-35104"></A><EM CLASS="FunctionName">
GRgetchunkinfo</EM>
 retrieves chunking information about the raster image into the parameters <EM CLASS="VarName">
c_def</EM>
 and <EM CLASS="VarName">
flag</EM>
 in C and into  the parameters <EM CLASS="VarName">
dim_length</EM>
 and <EM CLASS="VarName">
flag</EM>
 in FORTRAN-77.  Note that only chunk dimensions are retrieved; compression information is not available.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-38206"></A>The value returned in the parameter <EM CLASS="VarName">
flag</EM>
 indicates whether the raster image is not chunked, chunked, or chunked and compressed. <EM CLASS="DefName">
HDF_NONE</EM>
 (or <EM CLASS="DefName">
-1</EM>
) indicates that the raster image is not chunked. <EM CLASS="DefName">
HDF_CHUNK</EM>
 (or <EM CLASS="DefName">
0</EM>
) indicates that the raster image is chunked and not compressed. (<EM CLASS="DefName">
HDF_CHUNK | HDF_COMP</EM>
) (or <EM CLASS="DefName">
1</EM>
) indicates that raster image is chunked and compressed with one of the allowed compression methods: RLE, Skipping Huffman, or GZIP.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-38207"></A>In C, if the raster image is chunked and not compressed, <EM CLASS="FunctionName">
GRgetchunkinfo</EM>
 fills the array <EM CLASS="VarName">
chunk_lengths</EM>
 in the union <EM CLASS="VarName">
c_def</EM>
 with the values of the corresponding chunk dimensions. If the raster image is chunked and compressed, <EM CLASS="FunctionName">
GRgetchunkinfo</EM>
 fills the array <EM CLASS="VarName">
chunk_lengths</EM>
 in the structure <EM CLASS="VarName">
comp</EM>
 of the union <EM CLASS="VarName">
c_def</EM>
 with the values of the corresponding chunk dimensions. Refer to <A HREF="UG_html-8.htm#50593878_24765" CLASS="XRef">Making a Raster Image a Chunked Raster Image: GRsetchunk</A> on <EM CLASS="FunctionName">
GRsetchunk</EM>
 for specific information on the union <EM CLASS="DefName">
HDF_CHUNK_DEF</EM>
. In C, if the chunk length for each dimension is not needed, <EM CLASS="DefName">
NULL</EM>
 can be passed in as the value of the parameter <EM CLASS="VarName">
c_def</EM>
.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-38222"></A>In FORTRAN-77, chunk dimensions are retrieved into the array <EM CLASS="VarName">
dim_length</EM>
.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-55500"></A><EM CLASS="FunctionName">
GRgetchunkinfo</EM>
 returns <EM CLASS="DefName">
SUCCEED</EM>
 (or <EM CLASS="DefName">
0</EM>
) if successful and <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
) otherwise. The <EM CLASS="FunctionName">
GRgetchunkinfo</EM>
 parameters are discussed further in <A HREF="UG_html-8.htm#50593878_37735" CLASS="XRef">Table 8L</A>.</P>
</DIV>
<DIV>
<H6 CLASS="Heading3">
<A NAME="50593878_pgfId-35107"></A>	8.12.6	<A NAME="50593878_36329"></A>Setting the Maximum Number of Chunks in the Cache: GRsetchunkcache</H6>
<P CLASS="Body">
<A NAME="50593878_pgfId-36278"></A><EM CLASS="FunctionName">
GRsetchunkcache</EM>
<A NAME="50593878_marker-55892"></A> sets the maximum number of chunks to be cached for chunked raster image. <EM CLASS="FunctionName">
GRsetchunkcache</EM>
 has similar behavior to <EM CLASS="FunctionName">
SDsetchunkcache</EM>
. Refer to <A HREF="UG_html-3.htm#50593873_30563" CLASS="XRef">Setting the Maximum Number of Chunks in the Cache: SDsetchunkcache</A> for specific information. The syntax of <EM CLASS="FunctionName">
GRsetchunkcache</EM>
 is as follows: </P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-44380"></A><EM CLASS="syntaxLang">
C:</EM>
		status = GRsetchunkcache(ri_id, maxcache, flags);</P>
<P CLASS="FM1-syntax">
<A NAME="50593878_pgfId-44381"></A><EM CLASS="syntaxLang">
FORTRAN:</EM>
	status = mgscchnk(ri_id, maxcache, flags)</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-44382"></A>The maximum number of chunks is specified by the parameter <EM CLASS="VarName">
maxcache</EM>
. Currently, the only valid value of the parameter <EM CLASS="VarName">
flags</EM>
 is <EM CLASS="DefName">
0</EM>
.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-32482"></A>If <EM CLASS="FunctionName">
GRsetchunkcache</EM>
 is not called, the maximum number of chunks in the cache is set to the number of chunks along the fastest-changing dimension. Since <EM CLASS="FunctionName">
GRsetchunkcache</EM>
 is similar to the routine <EM CLASS="FunctionName">
SDsetchunkcache</EM>
, refer to <A HREF="UG_html-3.htm#50593873_30563" CLASS="XRef">Setting the Maximum Number of Chunks in the Cache: SDsetchunkcache</A> for more detailed discussion of the routine’s behavior.</P>
<P CLASS="Body">
<A NAME="50593878_pgfId-126824"></A><EM CLASS="FunctionName">
GRsetchunkcache</EM>
 returns the value of the parameter <EM CLASS="VarName">
maxcache</EM>
 if successful and <EM CLASS="DefName">
FAIL</EM>
 (or <EM CLASS="DefName">
-1</EM>
) otherwise. The <EM CLASS="FunctionName">
GRsetchunkcache</EM>
 parameters are discussed further in <A HREF="UG_html-8.htm#50593878_37735" CLASS="XRef">Table 8L</A>.</P>
<DIV>
<H6 CLASS="Table">
<A NAME="50593878_pgfId-126832"></A><DIV>
<IMG SRC="UG_html-51.gif" ALT="">
</DIV>
<A NAME="50593878_37735"></A>G<A NAME="50593878_marker-126829"></A>Rsetchunk, G<A NAME="50593878_marker-126830"></A>Rgetchunkinfo,<A NAME="50593878_marker-126831"></A> GRsetchunkcache, GRwritechunk, and <BR>
	GRreadchunk Parameter Lists</H6>
<TABLE>
<TR>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-126835"></A>Routine Name </P>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-126836"></A>[Return Type]</H6>
<P CLASS="TableHead">
<A NAME="50593878_pgfId-126837"></A>(FORTRAN-77)</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-126839"></A>Parameter</P>
</TD>
<TD ROWSPAN="1" COLSPAN="2">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-126841"></A>Parameter Type</P>
</TD>
<TD ROWSPAN="2" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-126845"></A>Description</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-126851"></A>C</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableHead">
<A NAME="50593878_pgfId-126853"></A>FORTRAN-77</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="6" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-126857"></A>GRsetchunk</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-126858"></A>[intn]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-126859"></A>(mgschnk)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126861"></A>ri_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126863"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126865"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-126867"></A>Raster image identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126871"></A>c_def</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126873"></A>HDF_CHUNK_DEF</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126875"></A>N/A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-126877"></A>Chunk definition</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126881"></A>flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126883"></A>int32*</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126885"></A>N/A </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-126887"></A>Compression flags</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126891"></A>dim_length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126893"></A>N/A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126895"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-126897"></A>Chunk dimensions array</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126901"></A>comp_type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126903"></A>N/A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126905"></A>integer </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-126907"></A>Type of compression</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126911"></A>comp_prm</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126913"></A>N/A</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126915"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-126917"></A>Compression parameters array</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="4" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-126919"></A>GRgetchunkinfo</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-126920"></A>[intn]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-126921"></A>(mggichnk)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126923"></A>ri_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126925"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126927"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-126929"></A>Raster image identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126933"></A>c_def</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126935"></A>HDF_CHUNK_DEF</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126937"></A>N/A </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-126939"></A>Chunk definition</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126943"></A>dim_length</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126945"></A>N/A </P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126947"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-126949"></A>Chunk dimensions array</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126953"></A>flag</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126955"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126957"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-126959"></A>Compression flag</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="3" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-126961"></A>GRsetchunkcache</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-126962"></A>[intn]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-126963"></A>(mgscchnk)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126965"></A>ri_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126967"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126969"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-126971"></A>Raster image identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126975"></A>maxcache</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126977"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126979"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-126981"></A>Maximum number of chunks to cache</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126985"></A>flags</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126987"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126989"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-126991"></A>Flags determining routine behavior</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="3" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-126993"></A>GRreadchunk</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-126994"></A>&nbsp;</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-126995"></A>(mgrchnk/</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-126996"></A>mgrcchnk)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-126998"></A>ri_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-127000"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-127002"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-127004"></A>Raster image identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-127008"></A>origin</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-127010"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-127012"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-127014"></A>Array specifying the coordinates of the chunk</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-127018"></A>datap</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-127020"></A>VOIDP</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-127022"></A>&lt;valid_numeric_or_</P>
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-127023"></A>char_data_type&gt;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-127025"></A>Buffer with chunk data in pixel interlace mode</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="3" COLSPAN="1">
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-127027"></A>GRwritechunk</H6>
<H6 CLASS="ReturnType">
<A NAME="50593878_pgfId-127028"></A>[intn]</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-127029"></A>(mgwchnk/</H6>
<H6 CLASS="CellFunctionBold">
<A NAME="50593878_pgfId-127030"></A>mgwcchnk)</H6>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-127032"></A>ri_id</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-127034"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-127036"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-127038"></A>Raster image identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-127042"></A>origin</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-127044"></A>int32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-127046"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-127048"></A>Array specifying the coordinates of the chunk</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-127052"></A>datap</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-127054"></A>const VOIDP</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-127056"></A>&lt;valid_numeric_or_</P>
<P CLASS="CellParameter">
<A NAME="50593878_pgfId-127057"></A>char_data_type&gt;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellDescription">
<A NAME="50593878_pgfId-127059"></A>Buffer with chunk data in pixel interlace mode</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="50593878_pgfId-63474"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="50593879_pgfId-17782"></A>&nbsp;</P>
</DIV>
</DIV>
</DIV>
<HR><P><table id="Botofpage" border="0" width="850" cellspacing="0" cellpadding="0">      <tr>        <td align="left">        HDF 4.2.10 - February 2014<br/>        <a href="THG_Copyright.html">Copyright</a>        <td align="right">          <span style="font-size: 12px; font-weight: bold">            The HDF Group<br />          </span>          <span style="font-size: 12px">            <a href="http://www.hdfgroup.org">www.hdfgroup.org</a><br />            <img valign="bottom" border="0" src="images/help.jpg" height="12" alt="The HDF Group" valign="top" />          </span>        </td>      </tr>    </table></BODY>
</HTML>
